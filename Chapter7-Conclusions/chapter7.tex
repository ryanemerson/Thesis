\chapter{Conclusions}

% **************************** Define Graphics Path **************************
    \graphicspath{{Chapter7-Conclusions/Figs/Vector/}{Chapter3-Conclusions/Figs/}}

In this thesis we have explored the challenge of coordinating distributed transactions across partially replicated environments and designed a suite of protocols that, when used together, can provide increased transaction performance. 

In chapter 2 we began by examining related work in the field of atomic broadcast and multicast protocols, as well as the current state of existing coordination services, before providing an in-depth analysis of Red Hat's open source in-memory NoSQL database, Infinispan.  This analysis of Infinispan is essential for understanding our work, as all of our proposed solutions have been designed within the context of Infinispan's distributed transactions, and consequently our performance evaluation was also based upon their semantics.

In chapter 3, we proposed that an alternative system model, \textsf{AmaaS}, should be utilised for coordinating distributed transactions in partially replicated environments.  We advocate the use of an external ordering service to provide total ordering for multicast messages, as an alternative to Infinispan nodes executing atomic multicasts between themselves via the P2P model.  This was followed by the introduction and analysis of the fault-tolerant atomic multicast protocol \textsf{SCast}.  Performance evaluation in chapter 6 shows that, when the \textsf{SCast} protocol is utilised for coordinating transactions and the total number of destinations is greater than 3, the \textsf{AmaaS} model consistently outperforms the existing P2P protocols utilised by Infinispan.

Chapter 4 introduced the hybrid atomic broadcast protocol, \textsf{ABcast}, which was designed for providing state machine replication between replicas in an \emph{AmaaS} ordering service.  \textsf{ABcast} leverages a traditional deterministic protocol, \textsf{Base}, in conjunction with a new probabilistic protocol, \textsf{Aramis}, in order to create an \emph{abcast} protocol that provides low-latency message delivery in the absence of node failures and non-blocking message delivery in their presence.  Due to \textsf{Aramis}'s probabilistic guarantees, the \textsf{ABcast} protocol can only guarantee a message's atomicity with a probability close to 1; hence it is possible for some messages to be rejected by a destination if it arrives outside of the established total order.  This potential for message rejections motivated the analysis of potential strategies that could be adopted by the \textsf{SCast} protocol and the Infinispan transaction manager when such rejections occur.  

In order to maximise the potential of the \textsf{ABcast} protocol described in chapter 4, it was necessary for a bespoke flow control protocol to be created that utilises the calculations of \textsf{Aramis}'s DMC.  Therefore, Chapter 5 presented the rational and design of, \textsf{AFC}, a flow control protocol that we designed and implemented for use with \textsf{ABcast}.  This protocol was utilised in all of our experiments in order to prevent nodes becoming saturated by atomic broadcasts during our experiments.  

Chapter 6 presented the results of our extensive performance evaluation and shows that the \textsf{ABcast} protocol is able to maintain similar levels of performance to traditional deterministic atomic broadcast protocols in the absence of node failure, whilst providing non-blocking message delivery when they do occur.  With, on average, $> 10^4$ messages being delivered in the interim period between a node failure and the group membership services detecting it.  Furthermore, we have shown that the \textsf{ABcast} protocol is able to handle a large number of broadcasts ($10^7$) without a single message being rejected, even when liberal values for $\rho_{min}$ and $R$ are utilised.  

\section{Limitations}\label{sec:sum_limitations}
In our performance evaluation we have shown that \textsf{AmaaS} is an effective model for improving the performance of atomic multicasts, however our performance evaluation only considers a case where ten clients were issuing requests to the service at any one time.  It is inevitable that any \textsf{AmaaS} service will have an upper limit on the number of ordering requests that it can accommodate at anyone time.  Therefore, a limitation of the \textsf{AmaaS} approach is that the service will eventually have to start rejecting client requests when the number of requests becomes greater than its throughput capabilities.  This is an inherent limitation of using a centralised services and is an acknowledged limitation of other coordination services such as Chubby \citep{Burrows:2006:CLS:1298455.1298487}.  

Another key limitation of the \textsf{ABcast} protocol is the need for additional logic higher up the network, or application, stack in order to handle messages being rejected by \textsf{Aramis} when its probabilistic guarantees are not sufficient.  Examples of the additional logic required by \textsf{SCast} and Infinispan's transaction manager are presented in chapter 4.  From these examples it is clear to see that this additional logic can require substantial redesigning of existing systems and is often far from trivial to implement.  However, it is worth noting that this problem is not unique to \textsf{ABCcast} and similar additional logic is required if any other probabilistic atomic broadcast protocol is utilised.  

\section{Future Work}
This section explores potential future research problems that have arisen from the work documented in this thesis.

    \subsection{Multiple AmaaS Services}
    As stated in $\S$ \ref{sec:sum_limitations}, it is inevitable that an \textsf{AmaaS} ordering service will eventually become saturated by requests if the number of clients in the system continues to increase.  A possible solution to this problem is to utilise multiple ordering services simultaneously, with client nodes assigned a specific service that they must interact with.  This would allow multicasts to be sent between clients utilising the same service in much the same manner as requests are handled now.  However, if a client wishes to send a multicast between clients which utilise distinct ordering services, then it is necessary for these services to share state between themselves in order to service the client's request and return accurate predecessor data.  Enabling two ordering services to interact in such a way is far from trivial and is an interesting research challenge.  Furthermore, designing an algorithm to effectively partition clients in a way that minimises the frequency in which distinct ordering services need to interact is also non-trivial.  
        
    \subsection{Utilising ABcast for State Replication in Zookeeper}\label{sec:sum_fw_zoo}
    At present, the \textsf{AmaaS} protocol \textsf{SCast} presented in chapter 3 has only been utilised in a proof of concept implementation.  In order for it to be utilised in production systems, it would necessary for a standalone service that exposed an API to client nodes to be implemented.  One solution to this problem would be to utilise the existing Zookeeper implementation, which is open source and released under the Apache License Version $2.0$ \citep{ApacheLicense}, as a foundation for a new \textsf{AmaaS} service.  The existing protocol used by Zookeeper for state machine replication, ZAB, could be replaced with \textsf{ABcast}.  The \textsf{SCast} protocol could be then created as an additional application that resides on the Zookeeper nodes and utilises the underlying primitives exposed by Zookeeper for state machine replication in order to provide its own API for client multicasts.  Such a solution would not only provide a solid foundation for the ordering service, it would also enable existing applications that depend on Zookeeper to utilise the new implementation as the Zookeeper API would remain the same \footnote{Where possible.  The potential for state machine replication to fail because of \textsf{Aramis} rejecting a message could require some slight changes to Zookeeper's API.}.          
        
    \subsection{Extending Infinispan to Support AmaaS with ABcast}
    The performance evaluation presented in chapter 6 compares the performance of an \textsf{AmaaS} service utilising \textsf{SCast} and \textsf{ABcast}, with the performance of Infinispan's existing P2P protocol TOA.  In these experiments, we evaluate the performance of each approach by contrasting the performance of the underlying \emph{amcast} protocol when executing emulations of Infinispan transactions.  This is an effective way of comparing \emph{amcast} performance, however it does not take into account other factors relevant to Infinispan, such as the transaction abort rate \footnote{Transactions can abort when the WSC fails or when a \emph{amcast} violation has occurred in \textsf{SCast}}, and it does not allow industry standard benchmarks such as TPC-C \citep{TPC-C} to be evaluated.  
    
    In order to enable the measurement of such metrics, it is necessary for the Infinispan databases to be extended to support the \textsf{SCast} protocol.  Such an undertaking would require a large engineering effort, which was unfortunately beyond the scope of this project, as it would require the Infinispan system to be adapted to utilise \textsf{SCast} instead of \textsf{TOA} and for Infinispan's transaction manager be reimplemented so that it provides a recovery mechanism for handling \emph{amcast} violations.  Furthermore, as the \textsf{SCast} protocol depends on an external ordering service, it would also be necessary for a standalone service to be implemented similar to the solution described in $\S$ \ref{sec:sum_fw_zoo}.  