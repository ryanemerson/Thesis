\chapter{Conclusions}

% **************************** Define Graphics Path **************************
    \graphicspath{{Chapter7-Conclusions/Figs/Vector/}{Chapter3-Conclusions/Figs/}}

In this thesis we have explored the challenge of coordinating distributed transactions across partially replicated environments and designed a suite of protocols that, when used together, can provide increased transaction performance. 

In chapter 2 we begin by examining related work in the field of atomic broadcast and multicast protocols, as well as the current state of existing coordination services, before providing an in-depth analysis of Red Hat's open source in-memory NoSQL database, Infinispan.  This analysis of Infinispan is essential for understanding our work, as all of our proposed solutions have been designed within the context of Infinispan's distributed transactions, and consequently our performance evaluation was also based upon the semantics of these transactions.  

In chapter 3, we propose that an alternative system model, \textsf{AmaaS}, for coordinating distributed transactions in partially replicated environments.  We advocate the use of an external ordering service to provide total ordering to multicast messages, as an alternative to Infinispan nodes executing atomic multicasts via the P2P model.  This is followed by the introduction and analysis of the fault-tolerant atomic multicast protocol \textsf{SCast}.  Performance evaluation in chapter 6 shows that, when the \textsf{SCast} protocol is utilised for coordinating transactions, the \textsf{AmaaS} model consistently outperforms the existing P2P protocols utilised by Infinispan when the total number of destinations is greater than 3.  

Chapter 4 introduces the hybrid atomic broadcast protocol, \textsf{ABcast}, which leverages a traditional deterministic protocol, \textsf{Base}, in conjunction with a new probabilistic protocol, \textsf{Aramis}, in order to create an \emph{abcast} protocol that provides low-latency message delivery in the absence of faults and non-blocking message delivery in their presence.  Due to \textsf{Aramis} being a probabilistic protocol, \textsf{ABcast} can only guarantee message atomicity with a probability close to 1, hence it is possible for some destinations involved in a multicast to reject a message if it arrives outside of the established total order.  Therefore, we also explored several strategies that could be implemented by the \textsf{SCast} protocol and the Infinispan transaction manager in order to minimise the repercussions of \textsf{ABcast} rejecting a message sent between service nodes. 

In order to maximise the potential of the \textsf{ABcast} protocol described in chapter 4, it was necessary for a bespoke flow control protocol to be created that utilises the calculations of \textsf{Aramis}'s DMC.  Therefore, Chapter 5 presents the rational and design of, \textsf{AFC}, a flow control protocol that we designed and implemented for use with \textsf{ABcast}.  This protocol was utilised in all of our experiments in order to prevent nodes becoming saturated by atomic broadcasts during our experiments.  

Our performance evaluation in chapter 6 shows that \textsf{ABcast} is able to maintain similar levels of performance to traditional deterministic atomic broadcast protocols, whilst providing non-blocking message delivery when node failures occur.  With, on average, $> 10^4$ messages being delivered in the interim period between a node failure and the group membership services detecting it.  Furthermore, we have shown that \textsf{ABcast} is able to handle a large number of broadcasts ($10^7$), which are sent as fast as possible, without a single message being rejected, even when liberal values for $\rho_{min}$ and $R$ are utilised.  

\section{Limitations}\label{sec:sum_limitations}
In our performance evaluation we have shown that \textsf{AmaaS} is an effective model for improving the performance of atomic multicasts, however our performance evaluation only considers a case where ten clients were issuing requests to the service at any one time.  It is inevitable that any \textsf{AmaaS} service will have an upper limit on the number of ordering requests that it can accommodate at anyone time.  Therefore, a limitation of the \textsf{AmaaS} approach is that the service will eventually have to start rejecting client requests when the number of requests becomes greater than its throughput capabilities.  This is an inherent limitation of using a centralised services and is an acknowledged limitation of Google's Chubby \citep{Burrows:2006:CLS:1298455.1298487}.  

A key limitation of \textsf{ABcast} is the need for additional logic higher up the network or application stack in order to handle messages being rejected by \textsf{Aramis} if its probabilistic guarantees have failed.  Examples of the additional logic required by \textsf{SCast} and Infinispan's transaction manager are presented in chapter 4.  From these examples it is clear to see that this additional logic can require substantial redesigning of existing systems and is often far from trivial to implement.  However, it is worth noting that similar additional logic is also necessary if any other probabilistic atomic broadcast protocol is utilised and this problem is not unique to \textsf{ABCcast}.  

\section{Future Work}
This section explores potential future research problems that have arisen from the work documented in this thesis.

    \subsection{Multiple AmaaS Services}
    As stated in $\S$ \ref{sec:sum_limitations}, it is inevitable that an \textsf{AmaaS} ordering service will eventually become saturated by requests if the number of clients in the system continues to increase.  A possible solution to this problem is to utilise multiple ordering services simultaneously, with client nodes only interacting with a designated service.  This would allow multicasts to be sent between clients utilising the same service in much the same manner as requests are handled now.  However, if a client wishes to send a multicast between clients which utilise distinct ordering services, then it is necessary for these services to share state between themselves in order to service the clients request.  Enabling two ordering services to interact in such a way is far from trivial and is an interesting research challenge.  Furthermore, designing an algorithm to effectively partition clients in a way that minimises the number of times multiple ordering services need to interact is also non-trivial.  
        
    \subsection{Utilising ABcast for State Replication in Zookeeper}\label{sec:sum_fw_zoo}
    At present, the \textsf{AmaaS} protocol \textsf{SCast} presented in chapter 3 has only been utilised in proof of concept implementations.  In order for it to be utilised in production systems, it would necessary for a standalone service that exposed an API to client nodes to be implemented.  One solution to this problem would be to utilise the existing Zookeeper implementation, which is open source and released under the Apache License Version $2.0$ \citep{ApacheLicense}, as a foundation for a dedicated service.  The existing protocol used for state machine replication, ZAB, could be replaced with \textsf{ABcast} and a version of the \textsf{SCast} protocol could be created that utilises the underlying primitives exposed by Zookeeper and provides its own API for client requests.  Such a solution would not only provide a solid foundation for the ordering service, it would also enable existing applications that depend on Zookeeper to utilise the new implementation as the Zookeeper API would not have changed \footnote{Where possible.  The potential for state machine replication to fail because of \textsf{Aramis} rejecting a message could require some slight changes to Zookeeper's API.}.          
        
    \subsection{Extending Infinispan to support AmaaS with ABcast}
    In chapter 6 when comparing the performance of atomic multicast protocols we utilise an experiment that emulates Infinispan's transactions, opposed to Infinispan's real transaction manager.   Adapting Infinispan's transaction manager so that its total order transactions utilised \textsf{SCast}, instead of \textsf{TOA}, would enable the \textsf{AmaaS} and P2P approaches to be compared using rigorous industry standard benchmarks such as TPC-C \citep{TPC-C}.  Such an undertaking is a large engineering effort, which was unfortunately beyond the scope of this project.  Integrating our approach with Infinispan would not only require the implementation of a standalone \textsf{AmaaS} service ($\S$ \ref{sec:sum_fw_zoo}), but it would also require Infinispan's transaction manager to be rewritten in order to enable recovery from \textsf{amcast} violations caused by \textsf{Aramis} rejections in the ordering service.  