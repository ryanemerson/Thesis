\chapter{ABcast}

% **************************** Define Graphics Path **************************
    \graphicspath{{Chapter4-ABcast/Figs/Vector/}{Chapter4-ABcast/Figs/}}

In this chapter we  introduce a hybrid \emph{abcast} protocol, called \textsf{ABcast}, which provides non-blocking message delivery in the presence of node failures and low-latency message delivery in their absence.  This protocol was designed for use within the \textsf{AmaaS} system model, however the protocol can also be utilised in other environments where non-blocking \emph{abcast}s are required between a small number of nodes.  

First we introduce the rational behind utilising a Hybrid protocol and our design approach for \textsf{ABcast}, before detailing the protocol's requirements and assumptions.  This is followed by an in-depth look at the components required by \textsf{ABcast}, and how they have been implemented.  We then explore the two protocols used to create the hybrid solution in detail, outlining each protocols delivery and rejection criteria for \emph{abcast} messages in order to understand how the two individual protocols co-exist to create a low-latency non-blocking hybrid \emph{abcast} protocol.  Finally we discuss the limitations of the protocol's current design and the need for a bespoke flow control algorithm for use with \textsf{ABcast}.  

\section{Rational}
    In the previous chapter we introduce \textsf{AmaaS}, a new system model that aims to increase the transactional throughput of distributed in-memory transactional systems.  This model depends on a \emph{abcast} protocol to maintain a replicated state between the service nodes which provide multicast ordering to client nodes; where each multicast request requires a state change between service nodes.  For such a service to be viable it is vital that it provides low-latency responses to the requesting client nodes and can handle an increasing number of client requests as a the transactional system scales.  Furthermore it is essential that such a service maintains high-availability, even in the presence of node failures, as an entire cluster of client nodes are dependent on the service.  Therefore, is essential that the underlying \emph{abcast} protocol utilised by the service can provide both non-blocking and low-latency message delivery, to satisfy the clients requirements of highly-available and low-latency requests respectively.  
    
    The FLP impossibility\citep{Fischer:1985:IDC:3149.214121} dictates that in an asynchronous environment \emph{abcast} protocols must either admit blocking to meet its atomic guarantees or permit a likelihood of its guarantees not being met.  As  previously stated, known blocking protocols are of two types: GM dependent and Quorum based, both of which admit blocking in order to remain atomic.  The quorum based protocols block mildly due to false/valid suspicions of the leader node and GM protocols block severely but only in the presence of node failures.  Quorum based protocols provide non-blocking message delivery, however they only provide low levels of throughput as they are typically leader based, which will ultimately limit the scalability of the transactional system.  Furthermore, it is also possible (although unlikely in practice) that such protocols can become stuck indefinitely in a cycle of leader elections after the previous leader node has crashed or is falsely suspected of crashing.    On the contrary GM based protocols provide very low latency \emph{abcast}'s that can handle high levels of throughput, however the severe blocking inherent in GM protocols would critically undermine an \textsf{AmaaS} service's availability in the event of a service node crash.  
    
    From the disadvantages stated above, it is clear that protocols belonging to the blocking category of protocols are not best suited for use within \textsf{AmaaS}.  Therefore it is necessary for us to adopt the alternative approach and allow for the possibility that the atomic guarantees G1-G4 ($\S$ \ref{ssec:atomic_broadcast}) will not always be met.  Utilising probabilistic guarantees on message delivery is an established technique for increasing the scalability of network multicasting systems\citep{Kermarrec:2003:PRD:766617.766623}, and it is has also been applied to \emph{abcast} protocols.  
    
    Felber \emph{et al.} \citep{Felber01probabilisticatomic} propose an \emph{abcast} protocol, \textsf{PABCast}, that provides probabilistic guarantees on both message \emph{safety} and \emph{liveness}.  If these probabilistic guarantees are not met, then it is possible for only a subset of the destination set to receive a broadcast, or for all destinations to deliver the broadcast but in an inconsistent ordering.  The aim of the  \textsf{PABCast} protocol is to provide increased scalability for atomic broadcasts across large numbers of destinations, not a small subset of nodes as required by the \textsf{AmaaS} and as such the protocol does not consider throughput a primary concern.  This is evident in the protocols use of \emph{rounds} to regulate when a node can initiate a broadcast; a node cannot initiate a new broadcast until all broadcasts sent by the cluster in the current round have been delivered by the local node.  Ultimately this limits the sending node to a single broadcast at a time, which will clearly limit the protocol's throughput capabilities.  In the literature the performance of \textsf{PABCast} is evaluated using a simulation that focuses on the scalability of the system in terms of message cost as well as the likelihood of a broadcast's \emph{safety} and \emph{liveness} being violated due to the probabilistic guarantees not being met. The performance evaluation presented in the paper does not consider the throughput or latency of the \textsf{PABCast} protocol, and the protocol is only evaluated in a simulation so it is not possible to ascertain how such a protocol will function in an actual asynchronous system.  Ultimately \textsf{PABCast} is not suitable for use in the \emph{AmaaS} system model.  
    
    Our approach is to combine a deterministic and probabilistic \emph{abcast} protocol in order to create a hybrid protocol that can provide high-throughput, low-latency message delivery when node failures are absent, whilst providing non-blocking message delivery when node failures do occur or are suspected.  This hybrid protocol consists of the probabilistic protocol \textsf{Aramis} and the deterministic protocol \textsf{Base} which are combined to create the \textsf{Aramis} and \textsf{Base} Atomic Broadcast protocol - \textsf{ABcast}.  
    
    \textsf{Aramis} is a non-blocking \emph{abcast} protocol that guarantees G1, G2 and G4 with a probability close to 1; G3 is deterministic and will always hold.  It utilises the probabilistic synchronous model ($\S$ \ref{ssec:probabilistically_synchronous}), in conjunction with synchronised clocks, to calculate a probabilistic upper bound on \emph{abcast} delivery times; we refer to this upper bound as a message's delivery delay, $\Delta_m$.  Upon receiving an \emph{abcast} message, a destination node waits for the calculated delivery delay to expire before delivering the message to the application.  If a message $m$ does not reach its destination, $d$, before its delivery time, then it is possible for a subsequent message $m'$ to be delivered ahead of $m$ in the total order if $\Delta_m'$ expires before $m$ is received by $d$.  When such a scenario occurs the \emph{abcast} guarantees G1 and G4 will not be met and therefore the broadcast cannot be considered to be atomic.  Furthermore, it is necessary for $d$ to reject $m$ in order to prevent $m$ from knowingly been delivered in the wrong place in the total order; hence guarantee G2 is also not met.  
    
    A key advantage of the \textsf{Aramis} approach is that no message acknowledgements are required for a message to be delivered, instead it depends entirely on the calculated delivery delay.  Relying solely on this delay ensures that faulty nodes have no effect on the delivery of a message at correct nodes and it is therefore impossible for a message's delivery to become blocked.  Furthermore, as no quorums or acknowledgements are required, it is possible for  \textsf{Aramis} to tolerate at most $(n - 1)$ crashes when $n$ nodes are involved in a broadcast.  
    
    The \textsf{Aramis} protocol was developed to be risk adverse, with all probabilistic calculations designed pessimistically in order to ensure that the delivery delay is rarely exceeded by an \emph{abcast} message.  Furthermore, the delivery delay must always assume the worst case scenario will happen when the protocol is executing (e.g. the originator node crashing during broadcast) to ensure that such situations are catered for.  A consequence of this pessimism, is that the point-to-point latency of a \emph{abcast} message can be very large, typically 100-1000ms.  These large latencies are not appropriate for use in many systems, and especially not the \textsf{AmaaS} model, therefore the \textsf{Aramis} protocol alone is not sufficient for providing the low-latency, non-blocking \emph{abcast} messages required by \textsf{AmaaS}.  
    
    To counteract the large-latencies associated with the \textsf{Aramis} protocol, we decided that it was necessary for a second \emph{abcast} protocol, \textsf{Base}, to be utilised alongside \textsf{Aramis}.  The \textsf{Base} protocol is a GM based deterministic protocol, similar to NewTop\citep{Ezhilchelvan:1995:NFG:876885.880005}, that provides low-latency high throughput \emph{abcast}s at the expense of blocking when node failures occur. The protocol is acknowledgement based and consists of two phases: First the message's originator, $m.o$ broadcasts $m$ to all $d \in m.dst$; Secondly, all $d' \in m.dst - \{m.o\}$ send an acknowledgement, $ack(_{d'})$  to each $d \in m.dst$ whom upon receiving all of the acks can deliver $m$.  If a single $d \in m.dst$ crashes during the \emph{abcast}, then message delivery will be blocked, as its possible that some of the required acks will never arrive.  
    
    The \textsf{ABcast} hybrid protocols is created by utilising the delivery conditions of the \textsf{Base} protocol when no node failures are present and utilising those of \textsf{Aramis} when a broadcast message has not been delivered by \textsf{Base} after $\Delta_m$ has expired.  This approach provides the application with the low-latency of \textsf{Base} for the majority of message deliveries, whilst ensuring that a message will not wait on a acknowledgment for more than $\Delta_m$.  

%    % Introduce Base, necessary for normal operations. Keep the benefits of traditional GM based abcast protocols.
    % Base still has the problem of blocking, however the aramis protocol can be utilised alongise it so that messages don't block, rather they utilise the delivery delay of Aramis if Base progress stops.
    % In the worst case, if Aramis's delivery delay becomes too large, then the GM service utilised by base will simply unblock the message delivery and progress will continue.  
    % The remainder of this chapter ...
    
\newpage
\section{Assumptions}
	This section first defines the four key assumptions made when designing the \textsf{Aramis} protocol.  Before exploring each assumption in detail, explaining the rational behind each assumption as well as exploring the technologies required to ensure each assumption held.  

	\paragraph{Assumptions:}\hspace{0pt} \\
	\begin{description}
	
	% ******** Is this the case? Why?
		\item [\textbf{A1 - Fault Tolerance}] At most ($n-1$) of $n$ nodes involved in a multicast can crash. However, 2 or more nodes cannot crash within an interval of some finite duration $D$ that is smaller than a few seconds.
		
		\item [\textbf{A2 - Reliable Communication}] When an operative node multicast $m$ to all $m.dst$, all operative destinations $d \in m.dst$ will eventually receive $m$.
		
		All of the protocols presented in this thesis are implemented in Java using the JGroups \citep{JGroups} network framework.  JGroups provides a reliable UDP layer which guarantees that all UDP messages, sent by a protocol higher in the network stack, arrive at their destinations when node crashes do not occur.  This reliable UDP layer is placed below \textsf{Aramis} in the network stack to ensure that when messages are multicast they are received by all destinations; where a multicast consists of $m$ being unicast via UDP to each of its intended recipients.  
		
		When crashes occur, the use of reliable UDP alone is not enough to ensure that all of the operative destinations receive $m$.  Therefore, a reliable multicast, \emph{rmcast}, protocol is required to ensure \textbf{A2}.  The \emph{rmcast} protocol we utilise is based upon (INSERT REF), and is explored in detail in $\S$ \ref{ssec:rmcast}.  
		
		\item [\textbf{A3 - Synchronised Clocks}] At any moment, clocks of any two operative nodes are synchronised with a maximum error rate of $\epsilon$ with probability $\mathcal{P}_\epsilon \geq (1- 10^{-5}$).

        We meet \textbf{A3} by implementing the well known clock synchronisation algorithm \citep{Cristian:1996:SA:227210.227231}.  The details of our implementation and the parameters used are explored in $\S$ \ref{ssec:clocksynch}.
		
		\item [\textbf{A4 - Probabilistically Synchronous}] Let random variable $x$ denote the message communication delay between any pair of operative nodes. The maximum delay, $x_{mx}$, estimated by observing $NT_P$ number of transmissions in the recent past, is \emph{not} exceeded during $NT_F$, where $NT_F \leq NT_P$, number of future transmissions to unfold next, with a high probability ($1-q$).
		
    	\textbf{A4} is motivated by previous research conducted by Ezhilchelvan \emph{et al.} \citep{Ezhilchelvan:2010:LPR:1773912.1773927}, which proposes that the challenges of designing asynchronous distributed systems, namely the FLP impossibility, can be avoided by assuming that the underlying network communication is synchronous to a given probability.  This assumption is a foundation of the \textsf{Aramis} protocol and its ability to provide non-blocking \emph{abcast}, as the variable $x$ is utilised by the \textsf{Aramis} protocol to place an upper bound on the delivery delay of each \emph{abcast} message.  The measurement of $x$, and experiments used to validate \textbf{A4}, are presented in $\S$ \ref{ssec:dmc}.  	
	\end{description}
	
\section{Aramis Components}
In this section we detail the individual components required by the \textsf{Aramis} protocol.  For each component, we explain its purpose and design; with important implementation details highlighted where appropriate.  

    \begin{figure}[!h] 
        \centering    
         \includegraphics[width=0.8\textwidth]{components}
         \caption[Aramis Protocol Components Overview]{Aramis Protocol Components}
         \label{fig:aramis_components}
    \end{figure}
    
   Figure \ref{fig:aramis_components} provides an overview of all of the components required by the \textsf{Aramis} protocol; where FCC is a Flow-Control Component (\ref{ssec:fcc}), GM is the Group Membership service provided by JGroups, DMC is the Delay Measurement Component (\ref{ssec:dmc}) and \emph{rmcast} is the Reliable Multicast Component (\ref{ssec:rmcast}).  

	\subsection{Delay Measurement Component}\label{ssec:dmc}
	    \paragraph{NMC Validation}\label{a4_validation}\hspace{0pt} \\
            	%We conducted a series of experiments to test \textbf{A4}, which were executed on a local computer cluster.  These experiments consisting of a 
            	% Describe Experiment and execution environment
				% Results
				% Analysis
	    
	\subsection{Reliable Multicast}\label{ssec:rmcast}
	\subsection{Clock Synchronisation}\label{ssec:clocksynch}
	\subsection{Flow Control}\label{ssec:fcc}
	
\section{Atomic Broadcast Protocol}

    \subsection{Aramis}
    
	    \subsubsection{Delivery Conditions}    
	    
		\subsubsection{Delivery Delay}
			% Maths and the rational for their calculation. 
		\subsubsection{Rejected Messages}
			% Messages rejected if a later message has already been delivered.
			% Issue a warning, or throw exception.
		
		% Base delivery conditions
	\subsection{Base}
	% Vector clocks
	% Missing sequences
	% Delivery conditions - All acks sent and received
	
	\subsection{Optimisations}
	% Rho > )
	% Acks piggybacked on subsequent messages
		
\section{Summary}