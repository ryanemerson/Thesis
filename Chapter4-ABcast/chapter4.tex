\chapter{ABcast}

% **************************** Define Graphics Path **************************
    \graphicspath{{Chapter4-ABcast/Figs/Vector/}{Chapter4-ABcast/Figs/}}

In this chapter we  introduce a hybrid \emph{abcast} protocol, called \textsf{ABcast}, which provides non-blocking message delivery in the presence of node failures and low-latency message delivery in their absence.  This protocol was designed for use within the \textsf{AmaaS} system model, however it can also be utilised in other environments where non-blocking \emph{abcast}s are required between a small number of nodes.  

The remainder of this chapter is structured as follows:  First we introduce the rational behind utilising a Hybrid protocol and our design approach for \textsf{ABcast}, before detailing the protocol's requirements and assumptions.  This is followed by an in-depth look at the components required by \textsf{ABcast}, and how they have been implemented.  We then explore the two protocols used to create the hybrid solution in detail, outlining each protocol's delivery and rejection criteria for \emph{abcast} messages. Finally we discuss the limitations of the protocol's current design and the need for a flow control algorithm that is bespoke to \textsf{ABcast}.  

\section{Rational and Design Approach}
    In the previous chapter we introduce \textsf{AmaaS}, a new system model that aims to increase the transactional throughput of distributed in-memory transactional systems.  This model depends on an \emph{abcast} protocol to maintain the replicated state between the service nodes which provide multicast ordering to client nodes; with each multicast request requiring a state change between service nodes.  For an \textsf{AmaaS} service to be viable it is vital that it provides low-latency responses to the requesting client nodes, as well as being able to handle an increasing number of client requests as a the transactional system scales.  Furthermore, it is essential that such a service maintains high-availability, even in the presence of node failures, as an entire cluster of client nodes are dependent on the service.  Thus, it is essential that the underlying \emph{abcast} protocol utilised by the service can provide both non-blocking and low-latency message delivery in order to satisfy the clients requirements of highly-available and low-latency requests respectively.  
    
    The FLP impossibility \citep{Fischer:1985:IDC:3149.214121} dictates that in an asynchronous environment \emph{abcast} protocols must either admit blocking to meet its atomic guarantees or permit a likelihood of its guarantees not being met.  As  previously stated, known blocking protocols are of two types: GM dependent and Quorum based, both of which admit blocking in order to remain atomic.  The quorum based protocols block mildly due to false/valid suspicions of the leader node and GM protocols block severely but only in the presence of node failures.  Quorum based protocols provide non-blocking message delivery, however they only provide low levels of throughput as they are typically leader based, which ultimately limits the scalability of the transactional system.  Furthermore, it is also possible (although unlikely in practice) that such protocols can become stuck indefinitely in a cycle of leader elections after the previous leader node has crashed, or is falsely suspected of crashing.    On the contrary GM based protocols provide very low latency \emph{abcast}'s that can handle high levels of throughput, however the severe blocking inherent in GM protocols would critically undermine an \textsf{AmaaS} service's availability in the event of a service node crash.  
    
    From the disadvantages stated above, it is clear that protocols belonging to the blocking category of protocols are not ideal when utilised within \textsf{AmaaS}.  Therefore it is necessary for a non-blocking approach to be utilised, allowing for the possibility that G1-G4 ($\S$ \ref{ssec:atomic_broadcast}) will not always be met.  Utilising probabilistic guarantees on message delivery is an established technique for increasing the scalability of network multicasting systems\citep{Kermarrec:2003:PRD:766617.766623}, which has also been applied to \emph{abcast} protocols.  
    
    Felber \emph{et al.} \citep{Felber01probabilisticatomic} propose an \emph{abcast} protocol, \textsf{PABCast}, that provides probabilistic guarantees on both message \emph{safety} and \emph{liveness}.  If these probabilistic guarantees are not met, then it is possible for only a subset of the destination set to receive a broadcast, or for all destinations to deliver the broadcast but in an inconsistent ordering.  The aim of the  \textsf{PABCast} protocol is to provide increased scalability for atomic broadcasts across large numbers of destinations, not a small subset of nodes as required by the \textsf{AmaaS}.  As such the protocol does not consider throughput a primary concern.  This is evident in the protocols use of \emph{rounds} to regulate when a node can initiate a broadcast.  A node cannot initiate a new broadcast until all broadcasts sent by the cluster in the current round have been delivered by the local node.  Ultimately this limits the sending node to a single broadcast at a time, which clearly limits the protocol's throughput capabilities.  In the literature, the performance of \textsf{PABCast} is evaluated using a simulation that focuses on the scalability of the system in terms of message cost as well as the likelihood of a broadcast's \emph{safety} and \emph{liveness} being violated due to the probabilistic guarantees not being met. The performance evaluation presented in the paper does not consider the throughput or latency of the \textsf{PABCast} protocol, and the protocol is only evaluated using a simulation so it is not possible to ascertain how such a protocol will function in a live asynchronous system.  In conclusion, \textsf{PABCast} is not suitable for use in the \emph{AmaaS} system model.  
    
    Our approach is to combine a deterministic and probabilistic \emph{abcast} protocol in order to create a hybrid protocol that can provide high-throughput, low-latency message delivery when node failures are absent, whilst providing non-blocking message delivery when node failures do occur or are suspected.  This hybrid protocol consists of the probabilistic protocol \textsf{Aramis} and the deterministic protocol \textsf{Base} which are executed in parallel to create the \textsf{Aramis} and \textsf{Base} Atomic Broadcast protocol - \textsf{ABcast}.  
    
    \textsf{Aramis} is a non-blocking \emph{abcast} protocol that guarantees G1, G2 and G4 with a probability close to 1; G3 is deterministic and will always hold.  \textsf{Aramis} utilises the probabilistic synchronous model ($\S$ \ref{ssec:probabilistically_synchronous}), in conjunction with synchronised clocks, to calculate a probabilistic upper bound on \emph{abcast} delivery times; we refer to this upper bound as a message's delivery delay, $\Delta_m$.  
    
    Informally, \textsf{Aramis} works as follows:  Upon receiving an \emph{abcast} message, a destination node waits for the calculated delivery delay to expire before delivering the message to the application.  If a message $m$ does not reach its destination, $d$, before its delivery time, then it is possible for a subsequent message $m'$ to be delivered ahead of $m$ in the total order if $\Delta_m'$ expires before $m$ is received by $d$.  When such a scenario occurs the \emph{abcast} guarantees G1 and G4 will not be met and therefore the broadcast cannot be considered to be atomic.  Furthermore, it is necessary for $d$ to reject $m$ in order to prevent $m$ from knowingly been delivered in the wrong place in the total order; hence guarantee G2 is also not met.  
    
    A key advantage of the \textsf{Aramis} approach is that no message acknowledgements are required for a message to be delivered, instead it depends entirely on the calculated delivery delay.  Relying solely on this delay ensures that faulty nodes have no effect on the delivery of a message at correct nodes and it is therefore impossible for a message's delivery to become blocked.  Furthermore, as no quorums or acknowledgements are required, it is possible for  \textsf{Aramis} to tolerate at most $(n - 1)$ crashes when $n$ nodes are involved in a broadcast.  
    
    The \textsf{Aramis} protocol was developed to be risk adverse, with all probabilistic calculations designed pessimistically in order to ensure that the delivery delay is rarely exceeded by an \emph{abcast} message.  Furthermore, the delivery delay must always assume the worst case scenario will happen when the protocol is executing (e.g. the originator node crashing during broadcast) to ensure that such situations are catered for.  A consequence of this pessimism, is that the \emph{broadcast-to-delivery} latency of a \emph{abcast} message can be very large, typically 100-1000ms.  These large latencies are not appropriate for use in many systems, and especially not the \textsf{AmaaS} model, therefore the \textsf{Aramis} protocol alone is not sufficient for providing the low-latency, non-blocking \emph{abcast} messages required by \textsf{AmaaS}.   
    
    To counteract the large delivery latencies associated with the \textsf{Aramis} protocol, we decided that it was necessary for a second \emph{abcast} protocol, \textsf{Base}, to be utilised alongside \textsf{Aramis}.  The \textsf{Base} protocol is a GM based deterministic protocol, similar to NewTop\citep{Ezhilchelvan:1995:NFG:876885.880005}, that provides low-latency high throughput \emph{abcast}s at the expense of blocking when node failures occur. The protocol is acknowledgement based and consists of two phases: First the message's originator, $m.o$ broadcasts $m$ to all $d \in m.dst$; Secondly, all $d' \in m.dst - \{m.o\}$ send an acknowledgement, $ack(_{d'})$  to each $d \in m.dst$ whom upon receiving all of the acks can deliver $m$.  If a single $d \in m.dst$ crashes during the \emph{abcast},  then it is possible that some of the required acks will never arrive at all destinations, in which case message delivery is blocked until the GM service detects the crash and appropriate action is taken by the protocol.  
    
    In order to hone the advantages of both protocols it was necessary to create the hybrid protocol \textsf{ABcast}.  This protocol is created by utilising the delivery conditions of the \textsf{Base} protocol when no node failures are present, and utilising those of \textsf{Aramis} when a broadcast message has not been delivered by \textsf{Base} after $\Delta_m$ has expired.  This approach provides the application with the low-latency of \textsf{Base} for the majority of message deliveries, whilst ensuring that a message will not wait on a acknowledgement for more than $\Delta_m$ time.  In the event of a node failure the \textsf{Base} protocol does not have to wait for the GM service to detect a crash before message delivery becomes unblocked.  Instead, messages will be delivered by \textsf{Aramis} after $\Delta_m$ expires.  Therefore, when node failures are present the \textsf{ABcast} protocol will always allow for a greater throughput of delivered messages than a traditional GM based protocol, assuming that $\Delta_m$ remains smaller than the time it takes the GM to detect a node failure.  In the worse case, if the GM delay is smaller than $\Delta_m$, than the \textsf{Base} protocol can simply unblock its message buffer and continue to deliver messages without the use of \textsf{Aramis}.  Finally, in normal working conditions, the \textsf{ABcast} protocol should have similar performance to a traditional GM based protocol as, in the majority of cases, \textsf{Aramis} is not used for message delivery.  

As the \textsf{ABcast} protocol utilises the probabilistic protocol \textsf{Aramis}, it is possible for a node to miss a message in the total order if \textsf{Aramis} takes over message delivery.  However, as previously stated, in practice the probability of \textsf{Aramis} meeting its guarantees is close to 1.  Furthermore, as \textsf{Aramis} is only used when \textsf{Base} is slow or a node failures occurs, the probability of an \emph{abcast} message $m$ being missed in the total order is the product of two very small probabilities; \textsf{Base} not being able to deliver $m$ and \textsf{Aramis} failing $m$.  Therefore, in reality the occurrence of message miss-orderings is rare.  

In this section we have described the inspiration and rational behind the \textsf{ABcast} protocol, as well as presenting some high-level details of how the hybrid protocol functions.  In the next section we present the underlying assumptions made when designing \textsf{ABcast}, before detailing the specific components required to implement the protocol.  Lastly, we take in-depth look at both the \textsf{Aramis} and \textsf{Base} protocols, detailing the specifics of the each protocols delivery conditions as well as the maths behind \textsf{Aramis}'s probabilistic guarantees.  

\newpage
\section{Assumptions}
	This section first defines the four key assumptions made when designing the \textsf{Aramis} protocol. 

    \subsection*{Assumptions:}	
	\begin{description}	
	% ******** Is this the case? Why?
		\item [\textbf{A1 - Fault Tolerance}] \hfill \\
		At most ($n-1$) of $n$ nodes involved in a broadcast can crash. However, 2 or more nodes cannot crash within an interval of some finite duration $D$ that is smaller than a few seconds.
		
        \item [\textbf{A2 - Synchronised Clocks}] \hfill \\
		At any moment, clocks of any two operative nodes participating in a \textsf{ABcast} are synchronised.  
		
		We meet \textbf{A2} by implementing the well known clock synchronisation algorithm \citep{Cristian:1996:SA:227210.227231}.  The details of our implementation and the parameters used are explored in $\S$ \ref{ssec:clocksynch}.		
		
		\item [\textbf{A3 - Reliable Communication}] \hfill \\
		When an operative node broadcasts $m$ to all $m.dst$, all operative destinations $d \in m.dst$ will eventually receive $m$.  
		
		We use reliable UDP protocol to guarantee that all operative nodes receive $m$ in crash-free scenarios.  However, when crashes occur, the use of reliable UDP alone is not enough to ensure that all of the operative destinations receive $m$.  Therefore, a reliable broadcast, \emph{rbcast}, protocol is required to ensure \textbf{A3}.  The Reliable UDP and \emph{rbcast} protocol we use are explored in detail in $\S$ \ref{ssec:reliable_udp} and $\S$ \ref{ssec:rbcast}, respectively.  
		
		\item [\textbf{A4 - Probabilistically Synchronous}] \hfill \\
        Let random variable $x$ denote the message communication delay between any pair of operative nodes. The maximum delay, $x_{mx}$, estimated by observing $NT_P$ number of transmissions from the recent past, will \emph{not} be exceeded during $NT_F$ number of future transmissions that unfold next, where $NT_F \leq NT_P$ with a high probability ($1 - q$).
		
    	\textbf{A4} is motivated by previous research conducted by Ezhilchelvan \emph{et al.} \citep{Ezhilchelvan:2010:LPR:1773912.1773927} into PSM, which proposes that the challenges of designing asynchronous distributed systems, namely the FLP impossibility, can be avoided by assuming that the underlying network communication is synchronous to a given probability.  This assumption is a foundation of the \textsf{ABcast} protocol and its ability to provide non-blocking \emph{abcast}, as the variable $x$ is utilised by the \textsf{Aramis} protocol to place an upper bound on the delivery delay of each \emph{abcast} message.  The measurement of $x$, $x_{mx}$ and $q$, as well as past experiments used to validate \textbf{A4}, are presented in $\S$ \ref{ssec:dmc}.  	
    	
    	A consequence of this assumption, is that \textsf{ABcast} can only be utilised in data centres and cluster-based environments.  It is not suitable for use over the Internet, or similar networks that are susceptible to large fluctuations in network delays over a short period of time.  This is because frequent fluctuations in network delays would consistently undermine the assumptions of PSM.  
	\end{description}
	
\section{ABcast Components}
In this section we detail the individual components required by the \textsf{ABcast} protocol.  For each component, we explain its purpose and design; with important implementation details highlighted where appropriate.  All of the protocols presented in this thesis are implemented in Java using the JGroups \citep{JGroups} network framework.  

    \begin{figure}[!h] 
        \centering    
         \includegraphics[width=0.8\textwidth]{components_no_fcc}
         \caption[\textsf{ABcast} Protocol Components Overview]{\textsf{ABcast} Protocol Components}
         \label{fig:abcast_components}
    \end{figure}
    
   Figure \ref{fig:abcast_components} provides an overview of all of the components required by the \textsf{ABcast} protocol; where GM is the Group Membership service provided by JGroups, DMC is the Delay Measurement Component (\ref{ssec:dmc}) and \emph{rbcast} is the Reliable broadcast Component (\ref{ssec:rbcast}).  

	\subsection{Clock Synchronisation}\label{ssec:clocksynch}
	In order to provide synchronised clocks between nodes executing \textsf{ABcast}, we implemented the probabilistic clock synchronisation algorithm presented in \citep{Cristian:1996:SA:227210.227231} as a dedicated protocol in JGroups.  Cristain's algorithm is a master/slave protocol, that utilises a single master node's clock time to synchronise all of the slave nodes; with each slave periodically issuing a clock synchronisation request to the master in order to synchronise their clocks.  
			
			At any moment a slave's clock value is synchronised with the master node with a maximum error rate of $\epsilon$, with probability $\mathcal{P}_\epsilon \geq (1- 10^{-5})$. All of the experiments presented in this thesis utilise clock synchronisation with $\epsilon$ estimated as $1$ millisecond (ms).  A major consideration when estimating $\epsilon$ is the worst-case rate of clock drift between successive synchronisations. Ultimately, the longer the synchronisation interval, the larger the drift rate between clocks.  Estimation of $\epsilon = 1$ usually assumes an interval of $45$ minutes between synchronisations, however we use a shorter $15$ minute interval in order to increase $\mathcal{P}_\epsilon$.
			
			As each slave node synchronises its clock value with that of the master, it is possible for any two slave nodes to have a maximum error rate of $2\epsilon$.  This is because a slave $N_i$ could synchronise its clock behind the master's clock value by $\epsilon$ time.  Whereas, another slave $N_j$ could synchronise its clock ahead of the master by $\epsilon$. Hence, it is possible that $N_j.clockValue - N_i.clockValue = 2\epsilon$.  

    \subsection{Group Membership}\label{ssec:jgroups_gm}
	JGroups provides a GM service, called GMS which simply stands for Group Membership Service. GMS works as follows: upon discovering that a new node has joined the group or a node failure has occurred, GMS issues a new view to all of the protocols in the JGroups stack.  It is then the responsibility of the individual protocols to take the appropriate action when a new view is issued.  For example, unblocking message delivery if the local node was waiting for an acknowledgement from a node that is no longer present in the newly issued view.  	
	
	\subsection{Reliable UDP}\label{ssec:reliable_udp}
	JGroups provides a reliable UDP protocol, \textsf{UNICAST3}, which guarantees that all UDP messages sent by a protocol higher in the network stack arrive at their destinations when node crashes do not occur.  This reliable UDP layer is placed below \textsf{ABcast} in the network stack to ensure that when messages are broadcast they are received by all destinations; where a broadcast consists of $m$ being unicast via \textsf{UNICAST3} to each of its intended recipients.  
	
	As well as providing reliable UDP unicasts, the \textsf{UNICAST3} protocol provides \emph{node-to-node} ordering as default for each message sent.  This ordering means that if a node $N_i$ sends two consecutive unicast messages, $m_1$ followed by $m_2$, to $N_j$, then $N_j$ will not deliver $m_2$ until it has first delivered $m_1$.  This behaviour is not always appropriate, therefore \textsf{UNICAST3} allows for messages to be sent Out Of Band (OOB), which simply means that messages will be sent reliably but they will be delivered at a destination as soon as they are received, regardless of the messages that have (or have not) been delivered before it.  
	
	\subsection{Reliable Broadcast}\label{ssec:rbcast}
    In the event of a node failure Reliable UDP alone is not sufficient to ensure that assumption A3 holds.  This is because its possible for a messages originator, $m.o$, to crash during the unicasting of $m$.  Assume that $m.dst = \{N_i, N_j, N_k\}$ and $m.o = N_i$, if $N_i$ crashes after unicasting $m$ to $N_j$ then $N_k$ will never receive $m$.  Similarly, if $N_i$ crashes during the unicasting of $m$ to $N_j$ it is possible that $N_i$ managed to send $m$ at least once, in which case it may eventually be received by $N_i$.  Both scenarios highlight that an additional protocol is required to ensure that all $m.dst$ receive $m$ in the event of node failures.  
    
    To overcome the limitations of Reliable UDP we have implemented a Reliable Broadcast protocol, called  \emph{rbcast}, that sits above the Reliable UDP layer in the network stack.  This protocol is inspired by the work of  Ezhilchelvan \emph{et al.} \citep{ezhilchelvan2011near}, as it utilises redundant broadcasts in collaboration with PSM, to ensure that all destinations receive a broadcast.  Our \emph{rbcast} protocol has been designed specifically for use with PSM based protocols and consequently utilises some of the values from the DMC ($\S$ \ref{ssec:dmc}) as protocol parameters.  Utilising the values provided by DMC allows  \emph{rbcast} to place a probabilistic timeliness guarantee on each message that is reliably broadcast.  With a high probability, \emph{rbcast} can guarantee that an operative destination will receive a given $m$ within $D_m$ time even if $m.o$ crashes during the initial broadcast of $m$.  The remainder of this section describes the basic \emph{rbcast} protocol, whilst the calculations for $D_m$ are presented in $\S$ \ref{ssec:dmc}.
    
    \subsubsection*{\emph{rbcast} protocol}
    All messages broadcast via \emph{rbcast} include a tuple $\{m.o, m.seq\#, m.ts\}$ that uniquely identifies the broadcast.  Where $m.o$, short for message originator, is the address of the node that initiates a broadcast message; $m.seq\#$ is a sequence number unique to each sending node that is incremented after each broadcast and $m.ts$ is a timestamp of $m.o$'s synchronised clock.  The first two values of the tuple are sufficient to uniquely identify a broadcast, however $m.ts$ is required by the DMC to measure network latencies and the \textsf{Aramis} protocol to deliver messages after a calculated delay.  
    
    As previously stated, the \emph{rbcast} protocol utilises redundant broadcasts to ensure that all $d \in m.dst$ receive $m$.  The message originator $m.o$, broadcasts ($\rho + 1$) copies of $m$; where $\rho$ is a redundancy estimate provided by the DMC.  All copies of $m$ are identical to the original broadcast, except for the field $m.copy$ which identifies the current copy of $m$ being broadcast - $m.copy = 0,\ldots,\rho$.  Successive broadcasts of $m$ are made $\eta$ time apart to ensure that subsequent copies of $m$ do not effect the transmission delay of the preceding broadcast, which is vital for the DMC to accurately calculate the variables required by \emph{Aramis} and \emph{rbcast}.  Furthermore, the use of $\eta$ ensures that multiple copies of $m$ are not bundled into the same UDP packet by the underlying transmission protocol.\footnote{Bundling can simply be disabled for subsequent copies of $m$, however this would prevent $m.copy > 0$ from being bundled with future broadcasts $m'.copy = 0$, hence some performance benefits gains would be lost.}  Finally, in addition to the $m.copy$ field, each $m$ includes the values  $m.x_{mx}, m.\eta, m.\rho$ and $m.\omega$ all of which are calculated by $m.o$'s local DMC.  
    
    A \emph{rbcast} of $m$ is considered a success if every operative $d \in m.dst$ receives at least one copy of $m$.  Any destination $N_j$ that receives $m.copy = k < \rho$ cooperates to ensure this success.  A destination waits to receive $m.copy \geq k + 1 \geq$ within a timeout $t_1 = \eta + \omega$, where $\eta= m.\eta$ and $\omega=m.\omega$.  $m.\omega$ is $N_i$'s estimate of the network's Packet Delay Variation (PDV).  If $t_1$ expires, $N_j$ assumes that $N_i$ has crashed while broadcasting $m.copy = k$ and starts broadcasting $m.copy = k, k+1,\ldots, \rho$ on behalf of $N_i$. Note, $N_j$ rebroadcasts the same copy of $m$ ($k$) that it received as it does not know if all other $d \in m.dst$ have also received $m.copy = k$.  To reduce the possibility that no one else is acting on behalf of $N_i$, $N_j$ adds a further random wait, $\zeta$, which is uniformly distributed on ($0,\eta$), before broadcasting $m.copy = k$.  This process continues until all $d \in m.dst$ have received or broadcast $m$ with $m.copy = \rho$.  
    
    Note that if $N_i$ does not crash, or if it crashes and an operative $s$-node receives $m$, then $m$ is broadcast \emph{at least} ($\rho + 1$) times.  Conversely, if $N_i$ crashes during the initial broadcast of $m$, and no members of $m.dst - \{m.o\}$ receive a copy of $m$, then the broadcast has failed and $m$ is lost.  This is acceptable for \textsf{ABcast}, because if no $d \in m.dst - \{m.o\}$ receive $m$, then its not possible for an inconsistent total order of messages to occur between participants of an \emph{abcast}.  
    
    It is worth noting that in our implementations of \emph{rbcast}, every broadcast where $m.copy = 0$ is treated differently to subsequent broadcasts of $m$.  Copy 0 of $m$ is broadcast to all destinations using the default settings of Reliable UDP, i.e. messages are delivered in the same order that they were originally unicast from their source address.  This means that if node $N_i$ broadcasts $m$, followed by $m'$, it is not possible for any of the destinations to receive copy 0 of $m'$ before it has received $m$.  In normal conditions this is beneficial, as the latency values recorded by the DMC will take into account any backlog of messages that may have accumulated at the destination address.  However, if the transmission of $m$ is slow or becomes lost, than $m'$ cannot be delivered up the network stack to the \emph{rbcast} protocol until $m$ has been received.  This delay could undermine the timeliness guarantees $D_m$ calculated by the DMC, and ultimately lead to messages being rejected from the total order ($\S$ \ref{ssec:abcast_rejection}).  To overcome this issue all messages with $m.copy > 0$ are sent OOB, to ensure that they are delivered to the \emph{rbcast} protocol as soon as they are received by the destination node.  Therefore, if $m'.copy = 0$ has been received but not delivered to \emph{rbcast}, then $m'.copy = 1$ is delivered as soon as it arrives, bypassing the backlog of messages.  
    
    The calculations used to produce $x_{mx}, \eta, \rho$ and $\omega$ are discussed in detail in $\S$ \ref{ssec:dmc}.  
    
	\subsection{Delay Measurement Component}\label{ssec:dmc}
        For the sake of clarity, assumption A4 is repeated below:	
        
        \begin{quotation}
            The maximum delay, $x_{mx}$, estimated by observing $NT_P$ number of transmissions from the recent past, will \emph{not} be exceeded during $NT_F$ number of future transmissions that unfold next, where $NT_F \leq NT_P$ with a high probability ($1 - q$).
        \end{quotation}
	
        The delay measurement component is responsible for monitoring and observing the network latency of $NT_P$ transmissions from the recent past.  This recent past of latencies is then used to calculate various parameters that are required by the \emph{rbcast} and \textsf{ABcast} protocols for executing \emph{abcasts} in the near future.  Being conservative, we use $NT_F = 10\%$ of $NT_P$ and $NT_P=1000$; so, a \textsf{ABcast} node freshly estimates $x_{mx}$ for every 100 new delays it observes.  Each fresh estimation of $x_{mx}$ results in the recalculation of the following parameters: $\eta, \rho, q$ and $\omega$.  
        
        Latencies are measured by the DMC based upon the timestamp $m.ts$, which is included in every message $m$ that is broadcast via the \emph{rbcast} protocol.  As the clocks of all nodes executing the \textsf{ABcast} protocol are synchronised, it is possible to measure the one-way latency of each message that is received by a node.  For example, a node $N_i$ sends an \emph{rbcast} $m$ to $N_j$, upon receiving $m$, $N_j$ immediately records the latency $x$:

        \begin{equation*}
		     \begin{aligned}
		         x = (N_j.clockValue - m.ts) + 2\epsilon
		     \end{aligned}
        \end{equation*}        
        
        It is necessary to add $2\epsilon$ to each latency to ensure that if $N_j.clockValue$ is behind $N_i.clockValue$ by the maximum error of $2\epsilon$, a positive latency value is still recorded; this assumes that neither $N_i$ or $N_j$ is the clock master, in which case it is not possible for the max clock difference to be $2\epsilon$, only $\epsilon$, however as \emph{rbcast} operates independent of the clock synch algorithm $2\epsilon$ is pessimistically added to all latencies.  
                                
        The remainder of this section explores each of the parameters provided by the DMC, explaining what they represent and how they are calculated.  
        
        \begin{description}
        \item[\Huge$\boldsymbol{x_{mx}}$] \hfill \\
        $x_{mx}$ is simply the largest latency out of the $NT_P$ latencies observed in the recent past.  
        
        \item[\Huge$\boldsymbol{q}$] \hfill \\
                The parameter $q$ is the estimated probability that a transmission delay observed in the near future will exceed $x_{mx}$.  We estimate $q$ by observing the ratio of observed delays from the recent past that exceed $95\%$ of the recorded $x_{mx}$; thus, when more delays are observed closer to $x_{mx}$, $q$ tends to be large.  Although unlikely, it is possible that $q$ can be calculated as $1$ if all latencies in the recent past are the same, to avoid this we set a maximum value for $q$, $ q \leq q_{mx}$.  $q_{mx}$ is calculated as: 

        \begin{equation*}
		     \begin{aligned}
		          q_{mx} = \sqrt{1 - R^{(\frac{1}{n} - 1)}}
		     \end{aligned}
        \end{equation*}
        
        Where $R$ is a constant defined before run-time that specifies to what probability the system will be \emph{reliable}.  As the system is probabilistic the following must be true $R < 1$.  Note that $q$ cannot be accurately estimated, as it relates to future delays.  Therefore, \textsf{ABcast} uses $q$ estimates in a manner that accounts for potential inaccuracies and only for estimating one other parameter - $\rho$.
	
	    \item[\Huge$\boldsymbol{\rho}$] \hfill \\
	    $\rho$ is the parameter that determines the number of redundant broadcasts that are sent by the \emph{rbcast} protocol, with each broadcast sent $\rho + 1$ times.  The DMC utilies a constant $\rho_{min}$ which determines the lowest possible value for $\rho$ and is configured before runtime.  $\rho_{min}$ allows an application to artificially increase the amount of redundancy provided by the \emph{rbcast} protocol if a greater level of redundancy is required; $\rho_{min} = 1$ by default.
	    
	    Note, $\rho = 1$ is sufficient for crash-tolerance, however we estimate it so that at least one copy of $m$ reaches all operative nodes, other than $m.o$, within $x_{mx}$ delay and with a probability $> R$; more precisely, $\rho$ is estimated as the smallest integer that satisfies $\rho \geq \rho_{min}$ and

		\begin{equation*}
		    \begin{aligned}
		        (1-q^{\rho+1})^{n-1} > R
		    \end{aligned}
		\end{equation*}

        which can be re-arranged as:

        \begin{equation*}
		    \begin{aligned}
		        \rho > \frac{ln(1-R)}{ln(q)} -1 \qquad \mbox{\emph{where}} \qquad R=(R)^{\frac{1}{n-1}}
		    \end{aligned}
		\end{equation*}

        The inequality assumes that $m$ is multicast exactly ($\rho +1$) times in a crash-free manner and all $n-1$  intended recipients are operative. Both assumptions lead to a \emph{conservative} estimate of $\rho$. Moreover, for a given $R$, an integer $I =\rho_{min}, \rho_{min} + 1, \ldots$, satisfies: 

        \begin{equation*}
		    \begin{aligned}
		        I < \frac{ln(1-R)}{ln(q)}-1 < I+1
		    \end{aligned}
		\end{equation*}
		
        for a wide range of $q$ values; e.g., for $R \approx 0.9999$:

        \begin{equation*}
		    \begin{aligned}
                \frac{ln(1-R)}{ln(q)}-1 < 1 \quad \forall \quad q < 0.01 = 1\%
		    \end{aligned}
		\end{equation*}

        Thus, small inaccuracies in estimating $q$ may not adversely affect $\rho$ estimates.  

        \item[\Huge$\boldsymbol{\eta}$] \hfill \\
        $\eta$ is the parameter used by \emph{rbcast} to determine the amount of time to wait between each broadcast of a message copy and is calculated as the largest delay in $n - 1$ transmissions (of a given copy $m$) with probability $R$.  Assuming exponential distribution $n$ is calculated as follows:
        
		% \eta=-\bar{x}[ln(1-R^{\frac{1}{n-1}})]     
		% \eta=-\bar{x}[ln(1-R)]  
        \begin{equation*}
		    \begin{aligned}
		        \eta=-\bar{x}[ln(1-R^{\frac{1}{n-1}})]  
		    \end{aligned}
		\end{equation*}
		
Where $\bar{x}$ is the exponential mean of $NT_P$ observed delays.

        \item[\Huge$\boldsymbol{\omega}$] \hfill \\
        $\omega$ is the parameter utilised by \emph{rbcast} to approximate the PDV encountered by the network.  $\omega$ is simply calculated as:
        
        \begin{equation*}
		    \begin{aligned}
		        \omega = \eta - \bar{x}
		    \end{aligned}
		\end{equation*}        
        
        Again, we assume exponential distribution and that $\bar{x}$ is the exponential mean of $NT_P$ observed delays.
        \end{description}

        \subsection*{Probabilistic Timeliness Guarantee - $\boldsymbol{D_m}$}
        The \emph{rbcast} protocol utilies the parameters provided by the DMC to apply a probabilistic timeliness guarantee to each broadcast sent by a node.  This timeliness guarantee ensures, with a high probability that all recipient nodes receive a message within $D_m$ time after the initial broadcast of $m$ was sent.  The remainder of this subsection details how $D_m$ is calculated and the rational behind the values used.  First we consider the calculations required for a broadcast where the originator does not crash, before exploring the modifications required to tolerate such a crash.  

        \begin{figure}[hb]
                \centering    
                \centerline{\includegraphics[width=1.15\textwidth, trim=0.1cm .25cm .1cm .25cm, clip=true]{rbcast_calculations}}
                \caption[Rbcast Calculations Diagram In a Crash Free Scenario]{Rbcast Calculations In a Crash Free Scenario}
                \label{fig:rbcast_calc}
            \end{figure}	

        \subsubsection*{Crash Free Message Originator}
        A node, $N_i$ broadcasts a message $m$ at time $ts$, $m.ts = ts$.  If $N_i$ does not crash then $D$ would be $D_1 = x_{mx} + \rho\eta$, as assumption \textbf{A4} means that $x_{mx}$ is the largest delay that will be encountered by $m$ and $\rho\eta$ accounts for the delays between successive copies of m being broadcast ($m.copy = 0,\ldots,\rho$).  Figure \ref{fig:rbcast_calc} shows the workflow of a message $m$ being \emph{rbcast} to $m.dst = \{N_i, N_j, N_k\}$ in a crash free scenario with $\rho = 2$; the individual parameters of $D_1$ are illustrated to show their significance.  
        
        Let $g_{D_1}$ be the probability that a destination, $N_j$, does not receive a single copy of $m$ at or before $ts + D1$.  Suppose that no node disseminates a copy of $m$ on behalf of $N_i$, and $\mathcal{P}(x > \xi)$ is the probability that a copy of $m$ takes longer than $\xi$ time to reach $N_{j}$.  The probability that none of the copies of $m$ broadcast at $ts, ts+\eta, \ldots,  ts+\rho \eta$, reaches $N_{j}$ by time $ts+D_1$, is:
        
        \begin{equation*}
		    \begin{aligned}
		        g_{D_1}= \mathcal{P}(x > D_1) \times \mathcal{P}(x > D_1 - \eta) \times \ldots \mathcal{P}(x > D_1 - \rho \eta)
		    \end{aligned}
		\end{equation*}

		
		Recall that $q$ is the probability that a delay in $NT_F=100$ future transmissions exceed the maximum $x_{mx}$ observed in the past $NT_P=1000$ transmissions. Since:
        
        \begin{equation*}
		    \begin{aligned}
		        \mathcal{P}(x > D_1 - \rho \eta) = \mathcal{P}(x > x_{mx}) = q
		    \end{aligned}
		\end{equation*}
		
and $\mathcal{P}(x > \xi)$ decreases as $\xi$ increases, we have $g_{D_1} < q^{\rho+1}$.  Even if $q$ is as high as 1\%, we have $g_{D_1} < 10^{-4}$ when $\rho=1$. If some destination disseminates $m$ on behalf of $N_i$, $\rho$ effectively increases and therefore $g_{D_1}$ reduces further.

When $N_i$ does not crash, a crash of a destination node $N_{k}$ cannot undermine an operative destination $N_{j}$ from receiving $m$. So, the probability that all operative $s$-nodes receive $m$ at or before time $ts +D_1$ is:

        \begin{equation*}
		    \begin{aligned}
		        (1-Q_1)=(1-g_{D_1})^{n-1}>(1-q^{\rho+1})^{n-1}
		    \end{aligned}
		\end{equation*}

%            \begin{figure}[hb] 
%                \centering    
%                \centerline{\includegraphics[width=1.1\textwidth]{rbcast_calculations}}
%                \caption[Rbcast Calculations Diagram In a Crash Free Scenario]{Rbcast Calculations In a Crash Free Scenario}
%                \label{fig:rbcast_calc}
%            \end{figure}	

        \clearpage
        \subsubsection*{Crashed Message Originator}
Suppose now that $N_i$ crashes before completing redundant transmissions of $m$ and $n>2$. Consider the worst case that only one node, $N_j$, has $m$ with $m.copy=0$. (If $N_u$ has $m.copy>0$, then $N_i$ crashed only after it completed broadcasting $m.copy >= 0$, therefore some node other than $N_j$ has $m$ with a high probability).

If copy $m.copy = 0$ takes at most $x_{mx}$ to reach $N_j$ (which occurs with probability ($1-q$)), $N_j$ would start disseminating on behalf of $N_i$ at or before time:
        
        \begin{equation*}
		    \begin{aligned}
		        ts+ x_{mx} + \eta + \omega +\zeta
		    \end{aligned}
		\end{equation*}
		
Recall that $\zeta$ is the random wait that all disseminating nodes must observe before disseminating $m$, with $\zeta$ uniformly distributed on ($0, \eta$) .  Therefore, assuming that the observed $\zeta$ is the largest possible value possible, $\eta$, let us define: 

        \begin{equation*}
		    \begin{aligned}
		        D = x_{mx} + 2\eta + \omega + D_1
		    \end{aligned}
		\end{equation*}
		
By assumption \textbf{A1}, no other node can crash until at least $ts+D$. Thus, $N_j$ disseminates $m$, like $N_i$ in the crash-free case, to operative destinations which can now be at most $(n-2)$; so, all operative nodes receive $m$ at or before $ts +D$ with a probability: 
        
        \begin{equation*}
		    \begin{aligned}
		        (1-Q) = (1-g_{D_1})^{n-2}\times (1-q)>(1-q^{\rho+1})^{n-2}\times(1-q)
		    \end{aligned}
		\end{equation*}

Figure \ref{fig:rbcast_crash_calc} shows the workflow of a message $m$ being \emph{rbcast} by $N_i$ to $m.dst \{N_i, N_j, N_k\}$.  $N_i$ crashes after unicasting $m$ to $N_j$, therefore $N_j$ waits to receive $m.copy > 0$ from $N_i$ for $2\eta + \omega$ time, before disseminating $m$ to the remaining destination $N_k$.  

In the event that $n = 2$, only two scenarios are possible in the event of $N_i$ crashing during the original broadcast of $m$.  Either $m.copy = 0$ is never received by the other node $N_j$, in which case $m$ is lost forever; Or $m.copy \geq 0$ is received by $N_j$, in which case $N_j$ will continue to broadcast the remaining copies of $m$ for completeness, however no other node will receive $m$ as no operative nodes remain.  For both scenarios, the delivery delay is calculated as $D_1$ as dissemination is not possible, therefore the probability that all operative nodes receive $m$ at or before time $ts+D_1$ is $(1-Q_1)$.  

To put the two cases together, $n > 2$ and $n = 2$, let boolean $\beta = 1$ if $n>2$ and $0$ if $n=2$; further, let: 

        \begin{equation*}
		    \begin{aligned}
		        D_m=\beta\times(x_{mx}+2\eta+\omega)+D_1
		    \end{aligned}
		\end{equation*}
		
When $N_i$ \emph{rbcast}s $m$ at its clock time $ts$, if some operative $s$-node receives $m$, then every operative $s$-node receives $m$ at or before time $m.ts+D_m$ (as per $N_i$'s clock) with a probability:

         \begin{equation*}
		    \begin{aligned}
		        \beta\times(1-Q)+(1-\beta)\times(1-Q_1)
		    \end{aligned}
		\end{equation*}

        \begin{sidewaysfigure}
            \vspace*{-1cm}
            \strictpagecheck
            \checkoddpage
            \ifoddpage
                \hspace*{-2.5cm}
            \fi           
            \centering
                \includegraphics[width=1.1\textwidth]{rbcast_crash_calculations}
            \caption[Rbcast Calculation Diagram with a Crashed Message Originator]{Rbcast Calculations with a Crashed Message Originator}
            \label{fig:rbcast_crash_calc}
       \end{sidewaysfigure}

	    %\paragraph{NMC Validation}\label{a4_validation}\hspace{0pt} \\
            	%We conducted a series of experiments to test \textbf{A4}, which were executed on a local computer cluster.  These experiments consisting of a 
            	% Describe Experiment and execution environment
				% Results
				% Analysis
				
\clearpage
\section{Atomic Broadcast Protocol}\label{sec:ABcast}
Hitherto this chapter has focused on the underlying assumptions made when designing the \textsf{ABcast} protocol and the components it requires to function.  This section details the specifics of the hybrid protocol, detailing the specifics of both the \textsf{Aramis} and \textsf{Base} protocols.  First we explore the \textsf{Base} protocol, as this protocol will be responsible for the majority of message deliveries and is the more conventional of the two \emph{abcast} protocols.  We then explore the \textsf{Aramis} protocol, detailing how messages are delivered and rejected as well as other related properties.  

    \subsection{Base}
    The \textsf{Base} protocol is based upon the NewTop \citep{Ezhilchelvan:1995:NFG:876885.880005} algorithm discussed in $\S$ \ref{ssec:newtop}, with a few key differences motivated by our use of synchronised clocks and PSM.  
    
    The \textsf{Base} protocol works as follows when a node $N_i$ sends an \emph{abcast} $m$: $N_i$ \emph{rbcast}s $m$, and as per the \emph{rbcast} protocol $m$ is assigned an id tuple $\{m.o, m.seq\#, m.ts\}$.  This tuple is utilised by \textsf{Base} to specify the total order of $m$, with all destinations in $m.dst$ ordering messages in ascending order based upon their timestamp.  In the event of any two message's having the same $m.ts$ value, the address specified in $m.o$ is used for tie-breaking to ensure a total order; note this is highly unlikely in practice as $m.ts$ is recorded in nanoseconds.  Similarly, In our implementation it is not possible for the same node to \emph{rbcast} two messages with the same $m.ts$, as a single thread called the \emph{sender} thread, is used for sending all $m$ with $m.copy = 0$.  Like NewTop, delivery of $m$ is blocked until each $d' \in m.dst - \{m.o\}$ has acknowledged $m$ by sending $ack_{d'}(m)$ to every $d \in m.dst$ and all $d \in m.dst$ have received $ack_{d'}(m) \forall (m.dst \setminus \{m.o,d\})$, thus C1 ($\S$ \ref{ssec:atomic_broadcast}) is met.  With each acknowledgement consisting of the id tuple that belongs to the message being acknowledged.  
    
    The use of synchronised clocks to uniquely timestamp each message, removes the need for tentative timestamps to be shared between destinations.  Instead the ordering of a message is dictated from its inception based upon its timestamp.  However a message's final place in the total order is not known by a destination until it has received an acknowledgement from all other $d' \in (m.dst - \{m.o\})$.  Consequently, the use of a message's id and acknowledgements are not sufficient for ensuring that C2 is met and G3-G4 are respected.  Consider $N_i$ \emph{rbcasts} two messages, $m$ and $m'$ with $m.seq\# = 1$ and $m.seq\# = 2$, respectively.  If a destination $N_j$ receives $m'$ first, then it knows that it has missed $m.seq\# = 1$, therefore it waits to receive and deliver $m$ before delivering $m'.seq\# = 2$, hence C2 is resolved.  Now consider a second scenario where two different nodes each \emph{rbcast} a message, $N_i$ sends $m$ and $N_j$ sends $m'$, where $m.ts < m'.ts$.  It is possible that $N_j$ will receive $ack_{N_i}(m')$ before $m$, in which case it will not know that $m$ should precede $m'$ in the total order, and as all acknowledgements have been received, $N_j$ will deliver $m'$, therefore violating G4.  
    
    In order to overcome the issues described above, each $d \in m.dst$ must maintain a \emph{vector clock}\citep{Mattern88virtualtime, fidge1988timestamps} that details the last \emph{rbcast} sent by $d$ and the id of the latest message received by each $d \in m.dst$; where the latest message received is the message containing the largest timestamp from a given node.  This vector clock is then included in every $m$ ($m.vc$) and $ack_{d'}(m)$ ($ack_{d'}(m).vc$) sent by a node.  Now lets reconsider the second scenario detailed above.  If $N_j$ receives $ack_{N_i}(m')$ before $m$, it will inspect $ack_{N_i}(m').vc$ and see that the last message that was \emph{rbcast} by $N_i$ was $m$, whose $m.ts < m'.ts$, therefore $N_j$ knows that they must deliver $m$ before $m'$.  For any message $m$, regardless of whether it originated at the current node, it is necessary for the associated acknowledgements and vector clocks to be checked to see if a message is missing from the total order before $m$ can be delivered.  If a node $N_i$ has not received $m$, but has learnt of its existence via a \emph{vector clock} or an acknowledgement, then we consider $m$ to be \emph{known} by $N_i$.  The \textsf{Base} delivery conditions are formalised below:
    
    \paragraph{\textsf{Base} Delivery Rule:}\hspace{0pt} \\
	    A node, $N_j$ delivers any $m$, via \textsf{Base}, only after $D1_B$ and $D2$ stated below are satisfied:
	    \begin{description}[labelindent=1cm]
	        \item[$\boldsymbol{D1_B}$] - $m$ is acknowledged by all nodes other than $m.o$. 
	        \item[$\boldsymbol{D2}$] - all \emph{known} $m'$, with $m'.ts < m.ts$ have been delivered.
	    \end{description}
    
    \subsubsection*{Acknowledgement Piggybacking}\label{ssec:base_ack_piggyback}
    In the explanation of \textsf{Base} we assume that each acknowledgement is explicitly sent as dedicated message, however in practice this is an expensive operation in terms of both latency and bandwidth.  Therefore in our implementation of \textsf{Base} we piggyback message acknowledgements on subsequent \emph{rbcast}s sent by an the acknowledging node; acknowledgements are piggybacked onto all copies of $m$, i.e. all $m.copy =0,\ldots,\rho$, or not at all.  Of course this is only appropriate if there is a message waiting to be \emph{rbcast}, otherwise deadlock will occur at all $d \in m.dst$ as an acknowledgement will never be sent.  Consider, node $N_j$ is attempting to send $ack_{N_j}(m)$ to $N_i$, if $N_j$ does not receive an \emph{abcast} request within $\mathcal{A}_d$ time, then an explicit acknowledgement message is sent to $N_i$ containing $ack_{N_j}(m)$, as well as any other pending acknowledgements.  We define $\mathcal{A}_d$ as $\mathcal{A}_d = 2\eta + \omega$ and an explicit acknowledgement as being a dedicated message $m_{ack}$ that is unicast to all $d \in m.dst$ and is not assigned a \emph{rbcast} id; hence only a single copy of $m_{ack}$ is broadcast via reliable UDP.  \footnote{Explicit acknowledgements are not \emph{rbcast} in order to further minimise the bandwidth cost of sending $m_{ack}$.}
    
    \subsubsection*{Aborting rho > 0}
    Another possible optimisation is for the \emph{rbcast}ing of a message $m$, to be aborted as soon as $m$ has been delivered at the local node via the \textsf{Base} protocol; this includes nodes that are disseminating $m$ or waiting on $m.copy > 0$.  The logic for this optimisation is as follows: If a node $N_i$ has delivered $m$ locally, then we know that all other $d' \in m.dst$ must have received $m$ as $N_i$ must have received $ack_{d'}(m)$ from all $d' \in m.dst$ in order for $m$ to have been delivered locally.  Therefore it is safe to abandon the \emph{rbcast}ing of $m$ as all $m.dst$ have received at least one copy of $m$. 
    
    Note, this optimisation has \textbf{not} been utilised in our implementation of the \textsf{ABcast} protocol.  This optimisation is not possible if a message has been delivered locally by the \textsf{Aramis} protocol as it is impossible to know for certain that all $d' \in m.dst$ have received $m$.  

    \subsection{Aramis}
    As previously stated,  \textsf{Aramis} is a non-blocking probabilistic \emph{abcast} protocol that utilises a calculated delivery delay $\Delta_m$ to place an upper bound on message deliveries.  The \textsf{Aramis} protocol works in conjunction with \textsf{Base} to ensure that message delivery does not become blocked in the event of slow or crashed nodes.  However, the \textsf{Aramis} protocol does not simply deliver each received message after $\Delta_m$ has expired, as this could cause a \emph{known} message to be missed in the total order.  Instead, it utilises the acknowledgements and \emph{vector clocks} that are integral to \textsf{Base} to ensure that \emph{known} messages are not missed from the total order.  Therefore, if a message $m$'s $\Delta_m$ delay expires, the message can only be delivered after all \emph{known} messages that precede $m$ in the total order have been delivered.  The \textsf{Aramis} delivery conditions are formalised below:
    
    \paragraph{\textsf{Aramis} Delivery Rule:}\hspace{0pt} \\
	    A node, $N_j$ delivers any $m$, via \textsf{Aramis}, only after $D1_A$ and $D2$ stated below are satisfied:
	    \begin{description}[labelindent=1cm]
	        \item[$\boldsymbol{D1_A}$] - The clock of $N_i > m.ts + \Delta_{m}$. 
	        \item[$\boldsymbol{D2}$] - All \emph{known} $m'$, with $m'.ts < m.ts$ have been delivered.
	    \end{description}
    
    
        \subsubsection*{Calculating $\boldsymbol{\Delta_m}$    }
		The delivery delay, $\Delta_m$ utilised by \textsf{Aramis} is calculated based upon the values utilised by \emph{rbcast} and produced by the DMC.  Consider the following scenario which explains the rational behind the delays calculation: When any operative node, $N_j$ receives $m$ \emph{rbcast} by $N_i$, all operative nodes receives $m$ with a high probability by time $m.ts + D_m$, as per $N_i$'s clock.  If each recipient piggybacks their $ack(m)$ onto one of its own \emph{rbcast}s within $\mathcal{A}_d$ time after receiving $m$, it is very likely that all $m.dst - \{m.o, N_j\}$ will receive $ack(m)$, as per $N_i$'s clock, before time:
		
		\begin{equation*}
		    \begin{aligned}
		        m.ts + 2\times{D_m} + \mathcal{A}_d
		    \end{aligned}
		\end{equation*}
		 
		 Based upon assumption A2, $N_j$'s clock has a maximum difference of $2\epsilon$ compared to $N_i$'s clock, with  probability $\mathcal{P}_\epsilon$, therefore $\Delta_m$ must be increased to cater for this, becoming:
		
        \begin{equation*}
		    \begin{aligned}
		        \Delta_m = 2 \times D_m + \mathcal{A}_d + 2\epsilon
		    \end{aligned}
		\end{equation*}		
		
		Thus, delivering $m$ via \textsf{Aramis} after a node's local clock time is greater than $m.ts + \Delta_m$ will meet \emph{abcast} guarantees G1-G4 with a high probability.
			    
		\subsubsection*{Total Order Violations}\label{ssec:abcast_rejection}
		In the explanations above, we have only considered the conditions required for a message to be successfully \emph{abcast} to all nodes.  However, as \textsf{Aramis} is a probabilistic protocol it is possible for a message to be delivered in the wrong place in the total order, thus violating G4.  For example, a message $m$ arrives at a destination after its proceeding message $m'$ in the total order has already been delivered, such that the total order is $<m', m>$ when it should be $<m, m'>$.  In such a case, their are two course of action possible when $m$ arrives: 1) Deliver $m$ as soon as possible; resulting in two violations of the total order occurring as $m$ has missed its place and then taken another's in the total order.  2) Receive $m$ and throw an exception to the application; resulting in only one violation of the total order, as $m$ is simply missing, but at the expense of violating G1 and G2 as $m$ cannot be delivered by all destinations.  \footnote{Assumption A2 guarantees that all destinations will eventually receive $m$, so if a message is not rejected then G1 and G2 always holds.}
		
		\textsf{Aramis} seeks to minimise the effects of a miss-ordered message, therefore it employs the second approach and throws an exception when a message has been missed in the total order; we refer to this process as a message being \emph{rejected}.  Explicitly \emph{rejecting} a miss-ordered message from the total order allows for higher levels in the network stack (e.g. \textsf{SCast}) to initiate an appropriate recovery mechanism to mitigate the effects of a miss-ordered message on the system's state.  Furtheremore, it is possible to include the contents of the rejected message in the \emph{rejection} exception in order to provide potential useful data to the application's recover mechanism.  
		
		The remainder of this section focuses on the scenarios in which it is possible for a message to be \emph{rejected} by a receiving node.  When the number of nodes, $n$, involved in an \emph{abcast} is $n=2$ the conditions required for a message to be rejected are different to $n > 2$, therefore we explore $n=2$ and $n>2$ in isolation. Note, for both $n=2$ and $n>2$ it is not possible for a broadcasting node to reject its own message, as by definition a broadcasting node will always receive its own message, hence G2 is always violated if a single node \emph{rejects} a message.  
		
		%\paragraph{Assumptions:}\hspace{0pt} \\
        \subsubsection*{Message Rejections - $\boldsymbol{n = 2}$}
        A message, $m$, sent by node $N_i$, can only be \emph{rejected} by the other recipient, $N_j$, when a message $m'$ from $N_j$ has been incorrectly delivered before $m$ in the total order; where $m.ts < m'.ts$ but the total order delivers $m'$ first, hence $m$ is \emph{rejected}.  In order for a message to be miss-ordered, both of the two statements below must be true:
        
        \begin{enumerate}
            \item $N_j$ broadcasts $m'$ with $m'.ts > m.ts$ and $m$ does not arrive at $N_j$ before $m'.ts + \Delta_{m'}$.  
            \item $N_j$ does not receive an acknowledgement for $m$, or any subsequent broadcasts sent by $N_i$, before $m'.ts + \Delta_m'$.   
        \end{enumerate}
        
        If condition one is not true, i.e. $m$ arrives before $m'.ts + \Delta_{m'}$, then $N_j$ has received $m$ before $m'$'s delivery time and therefore $N_j$ will not miss $m$ in the total order.  Similarly, if condition two is not true, then $N_j$ will know that a message sent by $N_i$ is missing as soon as it inspects the received acknowledgement, attached \emph{vector clock} or the $seq\#$ included in the id of the received message.  
        
        \subsubsection*{Message Rejections - $\boldsymbol{n > 2}$}
        If we assume the same scenario as described in the previous section ($n=2$), but with the addition of a node $N_k$ that represents all other nodes that are not $N_i$ or $N_j$.  A message is miss-ordered if conditions $1$ and $2$ stated above are true, and one of the following is true:
        
        \begin{itemize}
            \item[3a.] $N_j$ and all $N_k$ do not receive $m$ before $m'.ts + \Delta_{m'}$.
            
            \item[3b.] $N_j$ does not receive an acknowledgement for $m$ from any $N_k$, or a message from any $N_k$ that has received $m$, before $m'.ts + \Delta_{m'}$.  
        \end{itemize}
        
        If conditions $1,2$ and $3a$ are true, then it is not possible for $m$ to become known to $N_j$ as $m$ will not appear in an acknowledgement or vector clock of any $N_k$.  Similarly, if conditions $1,2$ and $3b$ are true, then $N_j$ will not know of $m$ in time to prevent $m'$ from being delivered before $m$ in the total order.  
        
        From both cases, $n=2$ and $n>2$, it is clear to see that in order for a message miss-ordering to occur, a chain of events need to occur that are highly unlikely based upon the probabilistic estimations made by the DMC and \emph{rbcast}.  
        		
    \subsection{ABcast Delivery Rule}
    Lastly, we present a concise formalisation of the delivery rule for the entire \textsf{ABcast} protocol.  A node, $N_j$ delivers any $m$, via \textsf{ABcast}, only after both $D1$ and $D2$ stated below are satisfied:
	    \begin{description}[labelindent=1cm]
	        \item[$\boldsymbol{D1}$] - The clock of $N_i > m.ts + \Delta_{m}$ ($D1_A$), or $m$ is acknowledged by all nodes other than $m.o$ ($D1_B$). 
	        \item[$\boldsymbol{D2}$] - All \emph{known} $m'$, with $m'.ts < m.ts$ have been delivered.
	    \end{description}
	    
\section{Limitations of ABcast}
The \textsf{ABcast} protocol described in this section functions as expected when each node's throughput is low, with the number of requests per second around five hundred.  However, in its current form the protocol has no flow-control, therefore as the number of requests per second increases the system starts to become saturated by requests.  The JGroups project provides an implementation of a credit based flow control protocol, however this is a generic solution that is aimed at deterministic protocols and as such does not take into account the unique requirements of the \textsf{ABcast} protocol nor does it take advantage of its probabilistic calculations.  Ultimately, a new bespoke flow control protocol is required for \textsf{ABcast} that utilises PSM and the measurements of the DMC.  Such a protocol is presented in the next chapter.  

\section{Summary}
This chapter presented \textsf{ABcast} - a new hybrid protocol that utilises both a deterministic (\textsf{Base}) and probabilistic (\textsf{Aramis}) protocol in order to create a non-blocking \emph{abcast} solution.  We detail the protocol's assumptions and required components, before detailing the delivery and rejection criteria of the two protocols.  Finally, we motivate the need for a flow control protocol that utilises the DMC's PSM calculations in order to maximise the throughput of the \textsf{ABcast}  protocol.  