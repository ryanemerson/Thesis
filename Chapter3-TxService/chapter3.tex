\chapter{AbaaS - Atomic Broadcast as a Service}

% **************************** Define Graphics Path **************************
\ifpdf
    \graphicspath{{Chapter3/Figs/Raster/}{Chapter3/Figs/PDF/}{Chapter3/Figs/}}
\else
    \graphicspath{{Chapter3/Figs/Vector/}{Chapter3/Figs/}}
\fi

%Introduction

This chapter introduces the concept of providing \emph{abcast} messaging as a service to members of a cluster.

First we describe the rational behind \textsf{Abaas}, then we explore the requirements of such a service and the challenges involves in meeting them.  This is followed by the introduction of the \textsf{ABService} protocol that is used to implement \textsf{AbaaS}.  We then explain the methodology used to evaluate \textsf{ABService}, before presenting the results of our performance evaluation.  Finally, we discuss the limitations of existing \emph{abcast} protocols in the context of \textsf{AbaaS}, and propose the need for a new non-blocking \emph{abcast} solution.  

\section{Rational}
Total order commit protocols can be utilised by distributed systems to coordinate transactions without the use of locks.  Reducing the abort rate of transactions when contention is high, as system deadlocks do not occur when distributed locks are not present.  Therefore, total order commit protocols aid scalability as they improve transaction throughput \citep{Ruivo:2011:ETO:2120967.2121604}.  

The limiting factor of total order commit protocols is the underlying \emph{abcast} protocol used to provide atomic guarantees on message delivery.  The TOA protocol currently utilised by Infinispan, does not scale well as the number of destinations $N$ increase, as $N->1$ communication is expensive ($\S$ \ref{TOA_limitations}).  Similarly, other GM protocols such as Newtop \citep{Ezhilchelvan:1995:NFG:876885.880005}, exasperate the problem, as the number of messages required to perform an \emph{abcast} increases dramatically as $N$ increases.  Finally, Quorum based protocols provide even less scalability, then GM based protocols, as their inability to \emph{abcast} messages to disjoint sets of nodes typically requires all nodes in the cluster to participate in an \emph{abcast}.  

Regardless of the \emph{abcast} protocol used, $N->1$ communication is inherently unscalable.  Therefore, we propose that obtaining a consensus on \emph{abcast} ordering should not be conducted between a transaction coordinator $Tx.c$ and its participating Infinispan nodes $Tx.dst$, but instead atomic ordering should be provided by an independent coordination service.  We call this Atomic Broadcast as a Service (\textsf{AbaaS}).  

Utilising \textsf{AbaaS} decouples message broadcasting from message ordering, by restricting the number of nodes requiring consensus to the nodes providing the services; known as \emph{service} nodes, or simply $s$-nodes, and denoted as $N_s$.  This means that regardless of $\left\vert Tx.dst \right\vert$, the number of messages required to obtain a total order for $Tx$ will always be equal to $\left\vert s\text{-nodes}\right\vert$.  

For a totally ordered 1PC transaction in Infinispan, \textsf{AbsaaS} works as follows: Once $Tx_i.c$ has completed its local execution of $Tx_i$, it is ready to \emph{abcast} a $prepare(Tx_i)$ message, $m$ for short.  $Tx_i.c$ selects some $s$-node and forwards $m$ with $m_i.dst = Tx_i.dst$ to the selected $s$-node, say, $N_s$, for \emph{amcast}ing $m$ to $m_i.dst$. $N_s$ actually \emph{amcast}s $m_i$ \emph{only} to other $s$-nodes using an \emph{abcast} protocol, which leads to all operative $s$-nodes delivering $m_i$. When $N_s$ delivers $m_i$, it returns $m_i$ to $Tx.c$, who then disseminates $m_i$ to every node $d$ indicated in $m_i.dst$ together with two types of order related information: $m_i.ts$ agreed by $s$-nodes and \emph{immediate} predecessor. The latter is the identity of $m_j$ whose delivery must \emph{precede} \emph{immediately} before delivery of $m_i$. More precisely, $d \in m_j.dst$, $d$ must not deliver $m_i$ until it delivers $m_j$, and no \emph{amcast} other than $m_i$ must be delivered immediately after $m_j$ is delivered.

Note that the immediate predecessor of $m_i$ with respect to \emph{all} \emph{amcast}s directed at a given $d$ - not just those that originate from $Tx_i.c$ nor just those that are handled only by $N_s$. Thus, it is specific to each $d$ and ensures that delivery at every $d$ is as per the finalized $m.ts$. To illustrate this, let $Tx_i.c$ submit $m_i$ to $N_s$, $Tx_j.c$ submit $m_j$ to $N_{s'}$ and $d \in m_i.dst \cap m_j.dst $. Say, $s$-nodes order $m_j$ before $m_i$. If $d$ receives $m_i$ before $m_j$, it will not deliver $m_i$ until it delivers $m_j$.

	\subsection{AbaaS Optimisations}

% Reduce N-1 communication, by utilising a small set of dedicated nodes to provide abcast for a cluster
% N-1 does not scale
% No overlapping subsets of destinations, fixed set, therefore always faster
% Allows for two optimisations that are not feasable in a traditional abcast solution:
	% Client Abcast requests can be bundled, regardless of m.dst. 
	% Single destination set allows for acknowledgments to be piggybacked, allowing for 1-phase abcast

\section{AbaaS System Requirements}
% Split into client and s-node requirements
	% Client Requirements:
		% What the Abaas System needs to provide consunmers
		% Ordering, previous orderings
		% Must be able to provide abcasts to multiple disjoint destination sets within a cluster of clients
		
	% S-node Requirements:
		% Consensus needs to be reached between s-node members in order to replicate abcast ordering returned to clients
		% S-nodes need to exchange as little data as possible to improve ordering time?????

\section{Abaas Protocol}
% Detail the protocol that I created
	% How it handles cascading orderings
% Explain the various optimisations that are possible
% Utilise diagrams to explain the architecture

\section{Experimentation}
% Explain - 10 clients, x box members etc.  Utilise Aramis paper
% Flow control used in the box and in traditional TOA.  

\section{Results}
% Utilise the graphs used in the Aramis paper, but without the Aramis results
% These graphs can then be used later, with the addition of the Aramis results in order to compare performance

\section{Limitations of Existing Atomic Broadcast Solutions}
% TOA blocks, which if a crash occurs inside the Abaas results in the entire cluster blocking
% Need a new non-blocking protocol that still allows high throughput i.e. not chubby, or zookeeper