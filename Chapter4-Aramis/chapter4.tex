\chapter{Aramis}

% **************************** Define Graphics Path **************************
    \graphicspath{{Chapter4-Aramis/Figs/Vector/}{Chapter4-Aramis/Figs/}}

This chapter introduces a non-blocking \emph{abcast} protocol, called \textsf{Aramis}, that utilises probabilistic guarantees on message ordering and delivery in order to prevent blocking when node failures occur.  This protocol was designed for use within the \textsf{AmaaS} service, however the protocol could also be utilised in other environments where non-blocking \emph{abcast}s are required between a small number of nodes.  

First we introduce the rational behind our design approach for \textsf{Aramis}, before detailing the protocol's requirements and assumptions.  This is followed by an in-depth look at the components required by \textsf{Aramis}, and how they have been implemented.  We then explore the protocol in detail, outlining the protocols delivery and rejection criteria for \emph{abcast} messages.  The experiments used to evaluate \textsf{Aramis} are then detailed, followed by an evaluation of the protocol's performance and the ramifications of our findings.  

\section{Rational}
	% AbaaS requires a non-blocking abcast protocol.  
	% FLP impossibility states that it is impossible for a protocol to be non-blocking and 100% deterministic.
	% Relax abcast guarantees in order to allow non-blocking performance. 
	
	
\newpage
\section{Assumptions}
	This section first defines the four key assumptions made when designing the \textsf{Aramis} protocol.  Before exploring each assumption in detail, explaining the rational behind each assumption as well as exploring the technologies required to ensure each assumption held.  

	\paragraph{Assumptions:}\hspace{0pt} \\
	\begin{description}
	
	% ******** Is this the case? Why?
		\item [\textbf{A1 - Fault Tolerance}] At most ($n-1$) of $n$ nodes involved in a multicast can crash. However, 2 or more nodes cannot crash within an interval of some finite duration $D$ that is smaller than a few seconds.
		
		\item [\textbf{A2 - Reliable Communication}] When an operative node multicast $m$ to all $m.dst$, all operative destinations $d \in m.dst$ will eventually receive $m$.
		
		All of the protocols presented in this thesis are implemented in Java using the JGroups \citep{JGroups} network framework.  JGroups provides a reliable UDP layer which guarantees that all UDP messages, sent by a protocol higher in the network stack, arrive at their destinations when node crashes do not occur.  This reliable UDP layer is placed below \textsf{Aramis} in the network stack to ensure that when messages are multicast they are received by all destinations; where a multicast consists of $m$ being unicast via UDP to each of its intended recipients.  
		
		When crashes occur, the use of reliable UDP alone is not enough to ensure that all of the operative destinations receive $m$.  Therefore, a reliable multicast, \emph{rmcast}, protocol is required to ensure \textbf{A2}.  The \emph{rmcast} protocol we utilise is based upon (INSERT REF), and is explored in detail in $\S$ \ref{ssec:rmcast}.  
		
		\item [\textbf{A3 - Synchronised Clocks}] At any moment, clocks of any two operative nodes are synchronised with a maximum error rate of $\epsilon$ with probability $\mathcal{P}_\epsilon \geq (1- 10^{-5}$).

        We meet \textbf{A3} by implementing the well known clock synchronisation algorithm \citep{Cristian:1996:SA:227210.227231}.  The details of our implementation and the parameters used are explored in $\S$ \ref{ssec:clocksynch}.
		
		\item [\textbf{A4 - Probabilistically Synchronous}] Let random variable $x$ denote the message communication delay between any pair of operative nodes. The maximum delay, $x_{mx}$, estimated by observing $NT_P$ number of transmissions in the recent past, is \emph{not} exceeded during $NT_F$, where $NT_F \leq NT_P$, number of future transmissions to unfold next, with a high probability ($1-q$).
		
    	\textbf{A4} is motivated by previous research conducted by Ezhilchelvan \emph{et al.} \citep{Ezhilchelvan:2010:LPR:1773912.1773927}, which proposes that the challenges of designing asynchronous distributed systems, namely the FLP impossibility, can be avoided by assuming that the underlying network communication is synchronous to a given probability.  This assumption is a foundation of the \textsf{Aramis} protocol and its ability to provide non-blocking \emph{abcast}, as the variable $x$ is utilised by the \textsf{Aramis} protocol to place an upper bound on the delivery delay of each \emph{abcast} message.  The measurement of $x$, and experiments used to validate \textbf{A4}, are presented in $\S$ \ref{ssec:dmc}.  	
	\end{description}
	
\section{Aramis Components}
In this section we detail the individual components required by the \textsf{Aramis} protocol.  For each component, we explain its purpose and design; with important implementation details highlighted where appropriate.  

    \begin{figure}[!h] 
        \centering    
         \includegraphics[width=0.8\textwidth]{components}
         \caption[Aramis Protocol Components Overview]{Aramis Protocol Components}
         \label{fig:aramis_components}
    \end{figure}
    
   Figure \ref{fig:aramis_components} provides an overview of all of the components required by the \textsf{Aramis} protocol; where FCC is a Flow-Control Component (\ref{ssec:fcc}), GM is the Group Membership service provided by JGroups, DMC is the Delay Measurement Component (\ref{ssec:dmc}) and \emph{rmcast} is the Reliable Multicast Component (\ref{ssec:rmcast}).  

	\subsection{Delay Measurement Component}\label{ssec:dmc}
	    \paragraph{NMC Validation}\label{a4_validation}\hspace{0pt} \\
            	%We conducted a series of experiments to test \textbf{A4}, which were executed on a local computer cluster.  These experiments consisting of a 
            	% Describe Experiment and execution environment
				% Results
				% Analysis
	    
	\subsection{Reliable Multicast}\label{ssec:rmcast}
	\subsection{Clock Synchronisation}\label{ssec:clocksynch}
	\subsection{Flow Control}\label{ssec:fcc}
	
\section{Atomic Broadcast Protocol}
	\subsection{Delivery Delay}
		% Maths and the rational for their calculation. 
	\subsection{Rejected Messages}
		% Messages rejected if a later message has already been delivered.
		% Issue a warning, or throw exception.
	
\section{Performance Evaluation}
	% Ran in the emulated transactions environment, very slow performance - due to large upper bound on delivery delays.
	% Not suitable for use as a standalone abcast protocol.
	% However, no rejections occurred - assumptions held.
	
\section{Summary}