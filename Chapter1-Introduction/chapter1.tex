\chapter{Introduction}
    % **************************** Define Graphics Path **************************
    \graphicspath{{Chapter1-Introduction/Figs/Vector/}{Chapter1-Introduction/Figs/}}
    
    The emergence and proliferation of mainstream cloud computing has facilitated the creation of a large number of Internet-scale web services and applications.  Such services serve millions of users across the globe simultaneously and are required to cater for increasingly large numbers of read and write operations on data with response times in the range of milliseconds. Cloud computing is ideal for such data loads, as it enables the web service to scale horizontally by dynamically acquiring resources as the rate or size of requests increases.  
    
    Traditionally, applications would utilise a Relational Database Management System (RDBMS) for storing and retrieving data.  However, as Internet scale services such as Facebook, Twitter and Google continued to receive increasing numbers of user requests, it became clear that RDBMS systems were unable to cope with such huge quantities of data \citep{DBLP:journals/corr/MoniruzzamanH13}.  The traditional approach to scaling RDBMS, was to scale \emph{vertically}, by utilising increasingly powerful and expensive servers to handle user requests.  Such an approach is not truly scalable as the maximum levels of performance will always be limited by the capabilities of the latest technology, the cost of hardware and the associated running costs.  Alternatively, it is possible to horizontally scale RDBMS solutions by partitioning data across several nodes in order to increase the number of machines that can handle user requests.  However, as RDBMS systems depend on a rigid data-schema to structure data horizontal partitioning is difficult in practice and often requires input from system administrators to maximise its effectiveness \citep{Han:6106531}.          
    
    The emergence of cloud computing as a cost effective model, combined with RDBMS's inability to elastically scale, has led to the emergence of NoSQL databases as an alternative storage solution.  These databases typically offer simpler data models and more relaxed consistency criteria than traditional RDBMS systems, in order to: $(i)$ avoid the need for predefined data schemas that hinder elasticity and $(ii)$ reduce the overhead of maintaining data replicas across multiple nodes \citep{Cattell:2011:SSN:1978915.1978919}.  Consequently, NoSQL stores are highly elastic and very well suited to cloud environments.  
    
    NoSQL databases can effectively utilise horizontal scaling in order to service an increasing number of application requests, whilst also providing increased fault-tolerance, via data replicas that are distributed throughout the cluster.  Utilising multiple data replicas allows for increased levels of throughput as application read requests can be serviced by multiple nodes simultaneously.  However, a consequence of utilising distributed replicas is that each write operation requires several Remote Procedure Calls (RPC) in order to maintain a consistent state between all of the data replicas; with a consensus being required between all data replicas for each write operation, as all replica hosts must perform write operations in the same order.  This additional cost associated with write operations is the primary motivation for NoSQL databases providing weaker consistency guarantees than the traditional 1-copy serialisability provided by ACID transactions in RDBMS.  
            
    Infinispan \citep{Infinispan} is an open source NoSQL database that stores user values in a key/value model and is developed by Red Hat, Inc \citep{RedHat}.  Unlike many NoSQL databases, Infinispan provides support for ACID transactions, however it utilises reduced levels of \emph{isolaton} than the traditional 1-copy serialisability in order to improve performance and scalability.  Infinispan's Distributed transactions are coordinated between peers in a \emph{peer-to-peer} (P2P) manner, using either the classical 2-Phase commit protocol or a lock free total order commit protocol that relies on an atomic multicast protocol.  Existing research \citep{Ruivo:2011:ETO:2120967.2121604} shows that utilising the latter improves performance over 2-Phase commit with respect to transaction abort rates, latency and throughput.  This increase in performance is due to the latter's reliance on a total order of messages, opposed to lock acquisition, to ensure that all data replicas perform write operations in the same order as it is not possible for distributed deadlocks to occur when no locks are used.  
    
    The total order commit protocol provided by Infinispan consistently outperforms 2-Phase commit, however our performance evaluation ($\S$ \ref{ch:perf_eval}) shows that the performance of the underlying atomic multicast protocol currently used for coordinating these transactions does not scale as the number of nodes involved in a transaction becomes greater than three; with the average transaction latency and throughput, increasing and decreasing respectively.  This is OK when the number of replicas for each data item is low, for example $2$, as a transaction involving a single write operation will only involve $2$ nodes, however if each key in the database is replicated more than twice, then performance begins to deteriorate.  Furthermore, this problems is exasperated when a transaction consists of multiple write operations.  For example, if a transaction consists of  $3$ write operations that are performed on distinct keys, and each key/value is replicated twice, then the total number of nodes involved in the transaction can be anywhere between $2$ and $6$ depending on how the keys are distributed across the Infinispan cluster.  Therefore, Infinispan's performance will suffer if an application requires key/values to be replicated more than twice and/or an application's workload consists of many transactions involving multiple write operations.  
    
    The scalability problem stated above is not unique to Infinispan's atomic multicast protocol, rather the same limitations apply to any distributed system that utilise P2P protocols in order to obtain consensus between a subset of nodes in a cluster.  Therefore, we define our problem statement for this thesis as designing alternative protocols for obtaining consensus between a subset of cluster nodes, in order to provide improved throughput and latency when coordinating transactions in partially replicated environments.  
    
    \subsection{Our Approach}    
    In this thesis we advocate an alternative approach to coordinating distributed transactions that does not require consensus to be reached between peers.  Our approach utilises two key components: an external ordering service that provides atomic multicasts and a non-blocking atomic broadcast protocol for state machine replication within the ordering service.  
   
   The external ordering service is an alternative to the P2P currently utilised by Infinispan and its purpose is to provide atomic multicasts between Infinispan nodes participating in transactions.  The rational behind this approach is that the number of nodes required to reach a consensus on a message's total order is limited to the number of nodes in the ordering service.  Therefore, as the number of nodes participating in a transaction increases, the time required to reach a consensus remains constant, hence the problems associated with P2P protocols are circumvented.

    Prior to this research, the throughput capabilities of such a service were limited by the protocols available to replicate state between the nodes providing the ordering service.  Existing coordination services, such as Zookeeper \citep{Hunt:2010:ZWC:1855840.1855851} and Chubby \citep{Burrows:2006:CLS:1298455.1298487}, utilise Quorum based atomic broadcast protocols for state machine replication.  Such protocols are advantageous as they do not block in the event of node crashes, however they are dependent on a 'leader' node for coordinating replication which becomes a performance bottleneck as the number of replications increases.  Such protocols are not suitable for our ordering service, as the service requires a node's state to be replicated each time an ordering request is received.  
    
    An alternative approach to the Quorum based protocols, are group membership dependent atomic broadcast protocols.  Such protocols do not utilise a leader node and provide the best possible throughput/latency when no node crashes occur, however they block severely when they do.  This blocking makes these protocols unsuitable for use within an ordering service as a single service node crash will prevent the ordering service from serving atomic multicasts to the Infinispan nodes, which in turn prevents any transaction in the cluster progressing.  

    The second aspect of our research was the development of a hybrid atomic broadcast protocol that can be utilised for state replication in the ordering service described above.  This protocol combines a deterministic atomic broadcast protocol with a probabilistic one, in order to provide low-latency atomic broadcasts in the absence of node crashes and non-blocking message delivery in their presence; with the probabilistic protocol guaranteeing atomicity with a probability close to 1.     
   
   Throughout this thesis we have utilising Infinispan as a basis for designing and implementing our solutions.  Infinispan was utilised because it is entirely open source and, at the time of writing, was the only in-memory NoSQL databases that provided support for coordinating ACID transactions via atomic multicasts.  Furthermore, this research was funded in its entirety by Red Hat, Inc who are responsible for the development of Infinispan.  